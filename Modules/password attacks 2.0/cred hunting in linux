
🧠 Cred Hunting in Linux — Mindset
🔍 Your job: After gaining a foothold, dig everywhere for creds that help escalate or pivot. Think: Where would a human screw up and leave sensitive info laying around?
The goal? Admin creds, password reuse, SSH keys, service creds, or escalation paths.

🧭 CATEGORIES TO HUNT
Think in 4 core buckets — files, memory, history, and system configs:

Category	Examples
🗂️ Files	Configs, scripts, databases, SSH keys
🧠 Memory	Running processes, keyrings, Mimipenguin
🕓 History	.bash_history, .bashrc, command logs
🧾 Logs	/var/log/*, cron logs, auth logs
🔽 FILES – THE LOW-HANGING FRUIT
🔧 Config Files (likely to contain creds)
bash
Copy
Edit
for l in .conf .config .cnf; do find / -name *$l 2>/dev/null; done
Then hunt inside for juicy lines:

bash
Copy
Edit
grep -iE 'pass|user' /path/to/file
🧠 Patterns to look for:

user = admin

password = hunter2

Hardcoded DB credentials, API keys, service creds

💽 Databases
bash
Copy
Edit
for l in .sql .db .db* .*db; do find / -name "*$l" 2>/dev/null; done
✅ Focus:

*.db from Firefox, Chrome, or apps like KeePass

.sql dumps, .sqlite storage

.tdb files = PulseAudio, possibly creds

📝 Notes (super common in real-world)
bash
Copy
Edit
find /home/* -type f \( -name "*.txt" -o ! -name "*.*" \)
Look for:

passwords.txt, secrets, creds, .bak, .old, .backup

Old dump files or dumped clipboard info

⚙️ Scripts
bash
Copy
Edit
find / -type f \( -name "*.sh" -o -name "*.py" -o -name "*.pl" \) 2>/dev/null
🧠 Why it matters:

Devs/admins hardcode creds for automation

connect_to_db('admin', 'supersecret')

export DB_PASS='letmein'

🕒 Cronjobs (often missed!)
bash
Copy
Edit
cat /etc/crontab
ls -la /etc/cron.{daily,hourly,weekly,d}
✅ Look for:

Scripts run as root

Commands in crontab pointing to sensitive files

Temp files with passwords generated by scripts

🔑 SSH Keys
Private Key:

bash
Copy
Edit
grep -rnw "PRIVATE KEY" /home/* | grep ":1"
Public Key:

bash
Copy
Edit
grep -rnw "ssh-rsa" /home/* | grep ":1"
🧠 If you find a private key:

Try SSH pivot

Test passwordless access

Decrypt .ppk if found (PuTTY format)

🧠 MEMORY (Post-root or sudo access)
🧠 Mimipenguin
bash
Copy
Edit
sudo python3 mimipenguin.py
✅ Pulls plaintext passwords from memory (like logged-in users, GNOME/LightDM)

🧠 LaZagne (Linux version)
bash
Copy
Edit
sudo python2.7 laZagne.py all
💥 Covers:

WiFi creds

Browser creds (Firefox/Chrome)

Shadow hashes

SSH, Docker, FileZilla, AWS, KeePass

🕘 HISTORY FILES
bash
Copy
Edit
tail -n 20 /home/*/.bash_history
✅ Look for:

Commands with passwords (curl, mysql, su, scp)

Scripts that might reference creds

Previous privilege escalation attempts

📑 LOGS
bash
Copy
Edit
for i in /var/log/*; do grep -iE "accepted|failure|sudo|ssh|new user|COMMAND=" $i 2>/dev/null; done
✅ Look for:

sudo usage

Service logs leaking credentials

New user creation

SSH login attempts

🔍 BROWSER-STORED CREDS (Firefox shown)
Dump profile:
bash
Copy
Edit
cat ~/.mozilla/firefox/*default*/logins.json | jq .
Decrypt with Firefox Decrypt:
bash
Copy
Edit
python3 firefox_decrypt.py
✅ Look for:

username + password

formSubmitURL — target login portal

Combine with browser cookies/sessions to hijack logins

🔥 TL;DR – Got This, Do That
Got This	Do That
Low-priv shell	Search for .conf, .sh, .py, .sql, .db
Root / sudo	Run Mimipenguin / LaZagne
User home access	Dump .bash_history, .ssh/, .mozilla/
Suspect credentials exist	Search /etc/cron*, /var/log/, browser files
Found SSH key	Attempt SSH lateral movement
Found hash only	Try john or hashcat, or test PtH if NT hash
🧪 Exam Angle
You'll likely be placed on a Linux host and expected to enumerate creds fast.

Know how to:

find, grep, cat, jq

Pipe results into filtering logic

Interpret script/config output

Expect to use LaZagne and Mimipenguin post-root.

Pillaging browser creds or hardcoded secrets is a common privilege escalation pivot.

✅ When You Get Shell on a Linux Host — What to Do First (CPTS + Real World)
🎯 1. Check If You're Already Lucky
bash
Copy
Edit
sudo -l
✅ If you get NOPASSWD + something juicy → game over, escalate.

❌ If it prompts for a password → time to hunt.

Think of sudo -l as the shortcut scan. If it’s closed, then we go full recon.

🪓 2. Start Credential Hunting Immediately
Why? Because stored creds = instant lateral, vertical, or post-exploit gains.

Hardcoded creds in configs/scripts

DB logins in .cnf, .env, .sh

SSH keys to pivot

Browser creds for portal access or reuse

Firefox/Chrome saved creds = godmode in corp setups

⚠️ In CPTS and real-world boxes, devs/admins leave keys and creds all over. This step is almost always fruitful, even if just for pivoting or escalation on another box.

🧠 3. Then Move Into Deeper Enumeration
Kernel version, exploits

SUID/GUID binaries

Capabilities

Running processes (pspy or manual)

LXD, Docker membership

Misconfigured services

💡 Think of cred hunting as “quick win scanning”. You can:

Escalate fast without needing kernel bugs or service exploits

Pivot across users or SSH boxes with legit creds

Extract hashes for offline cracking or PtH

🔥 TL;DR Workflow
bash
Copy
Edit
# Initial Instinct Tree
1. sudo -l                # Instant escalation check
2. find . -name "*.conf"  # Config creds
3. grep -rni "pass" ~ /   # Quick hit hunt
4. cat ~/.bash_history    # Did they give you creds?
5. Check ~/.ssh/          # SSH key access?
6. find . -name "*.sh"    # Scripting creds
7. Check logs / cron / keyrings / DBs / browsers
💭 CPTS Mental Model
If you don’t find creds within 5–10 minutes, shift focus to other priv esc vectors. But the first few minutes of pillaging can shortcut a 40-minute rabbit hole.
