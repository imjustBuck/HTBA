ğŸ§  Summary: Command Injection Prevention
This section explains how to prevent command injections at the dev and server config levels â€” because offense informs defense, and knowing what leads to exploitation helps you shut it down as a blue teamer, coder, or appsec engineer.

Itâ€™s broken into three main buckets:

ğŸ”’ Code-Level Mitigations â€“ Avoiding vulnerable functions, validating + sanitizing input.

ğŸ§¼ Input Filtering Techniques â€“ Whitelist vs blacklist, regex use, sanitization libraries.

ğŸ° Server Hardening â€“ Locking down the execution environment so even if something breaks, damage is minimal.

ğŸ’£ ITTTT: If This, Then Try That â€“ Prevention Flow
Got This Situation	Then Do This
Using user input in system commands	âŒ Donâ€™t. Use built-in language methods instead (e.g., fsockopen in PHP)
No alternative but to use system command	âœ… Validate & sanitize input rigorously
Need to validate format (e.g., IP)	âœ… Use filter_var() in PHP or regex in JS/Node
Want to sanitize input	âœ… Strip dangerous chars: preg_replace in PHP, .replace() in JS
Handling HTML or comments	âœ… Use libraries like DOMPurify (Node)
Still using special chars (e.g., quotes, pipes)?	âš ï¸ Escape only if absolutely necessary â€” escaping is fragile
Prevent exploitation on the backend	ğŸ›¡ï¸ Harden the server (PoLP, disable dangerous funcs, WAF, etc.)
Need to test app security	ğŸ§ª Combine secure coding with pen testing â€” one canâ€™t replace the other
ğŸ” Patterns, Techniques & Tips
ğŸ”§ 1. Avoid Dangerous Functions
Donâ€™t use system(), exec(), shell_exec() unless you absolutely have to.

Use built-in safe alternatives:

PHP: fsockopen() for host checks

NodeJS: Use is-ip, dns, etc.

ğŸ“¥ 2. Input Validation & Sanitization
âœ… Validate first â€” deny anything that doesnâ€™t match strict formatting.
âœ… Sanitize second â€” strip or encode what's not essential.

PHP:

php
Copy
Edit
filter_var($_GET['ip'], FILTER_VALIDATE_IP);
$ip = preg_replace('/[^A-Za-z0-9.]/', '', $_GET['ip']);
JavaScript / Node:

js
Copy
Edit
ip = ip.replace(/[^A-Za-z0-9.]/g, '');
Libraries:

DOMPurify (Node)

escape(ip) â†’ legacy, not recommended alone

âš ï¸ Blacklists like if strpos($input, 'cat') !== false are not safe. Bypassable AF.

ğŸ° 3. Server-Level Hardening
Defense-in-depth. Even if your code fails, your box shouldnâ€™t fall apart.

Action	Description
ğŸ”’ PoLP	Run app as low-privileged user (e.g., www-data)
ğŸš« disable_functions	Block dangerous PHP funcs (system, exec, etc.)
ğŸ“‚ open_basedir	Restrict app access to /var/www/html only
ğŸ§± Built-in WAFs	Apache mod_security, external WAFs (Cloudflare, Imperva)
ğŸ” Reject weird input	Block non-ASCII, double-encoded characters in URLs
ğŸ“¦ Donâ€™t use old garbage	Avoid vulnerable modules like CGI mode in PHP
ğŸ” Final Thought from a Blue Team Perspective
Command Injection == game over if successful.

But combined layers:

Proper coding

Input controls

Hardened OS

App monitoring

Alerts in Splunk/SIEM

Thatâ€™s what buys time for detection + response.

"Any single line in a million lines of code can be the hole."
That's why automated scanning + human validation = key.

