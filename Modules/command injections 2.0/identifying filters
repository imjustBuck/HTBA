ğŸ§  Summary: Identifying Filters (Back-End & WAF)
After discovering a potential command injection point, our payloads might suddenly stop working.
Why? There's a back-end filter or a Web Application Firewall (WAF) blocking them.

This section walks you through:

Recognizing when your injection is blocked

Figuring out what exactly is being filtered

And setting the stage for bypassing it later

ğŸ” Filter/WAF Detection Logic
ğŸ”º Scenario:
You use a payload like:

bash
Copy
Edit
127.0.0.1; whoami
And get a "Invalid input: Filter" error.

That means your injection was caught by:

âŒ A back-end filter (like PHP code rejecting certain chars)

âŒ Or a WAF (more aggressive; may redirect or show a detailed error page)

ğŸ” How Filters Work
Letâ€™s say they use this PHP logic:

php
Copy
Edit
$blacklist = ['&', '|', ';', ...];
foreach ($blacklist as $character) {
    if (strpos($_POST['ip'], $character) !== false) {
        echo "Invalid input";
    }
}
That means:

ANY of these characters â†’ ;, &, | â†’ in your input?
â›”ï¸ Blocked immediately

ğŸ› ï¸ Identifying Whatâ€™s Being Blocked
You do this methodically, testing one piece at a time:

âœ… You start with safe:
Copy
Edit
127.0.0.1
â†’ Works just fine.

âŒ Then try:
Copy
Edit
127.0.0.1;
â†’ Blocked â†’ so ; is blacklisted

Repeat this for:

&&

||

|

&

Subshells like `whoami` and $(whoami)

This tells you which characters are tripping the filter.

âš¡ï¸ Got This, Do That (ITTTT Style)
ğŸ§© Got This: You test a known payload (e.g., 127.0.0.1; whoami) and see â€œInvalid Inputâ€
âœ… Do That:
â†’ Break it down piece by piece to isolate the blacklisted character(s)

ğŸ•µï¸ Got This: Only certain characters like ; or && are blocked
âœ… Do That:
â†’ Try alternate operators (|, &, backticks, $(), newline %0a, etc.)
â†’ This sets you up for filter evasion

ğŸ›¡ï¸ Got This: Error page looks different, maybe shows request/IP
âœ… Do That:
â†’ Suspect a WAF (not back-end filtering) â†’ Try alternate encoding or user-agent spoofing in Burp

ğŸ§  Patterns & Hints
ğŸ” Situation	ğŸ’¡ What It Hints
â€œInvalid inputâ€ in the same field	Likely app-side filtering (PHP, etc.)
New page with request details/IP shown	WAF likely triggered
Only ; is blocked	Try using &&, `
Full word (e.g. whoami) causes block	Try command obfuscation (wh$@oami, etc.) later
Filters only on front-end	Use Burp to bypass UI validation entirely
ğŸ”¥ TL;DR Takeaway
This section is about identifying why your working payloads suddenly get denied. You're sniffing out whatâ€™s filtered (usually special chars) so you can plan how to evade in the next section.

ğŸ› ï¸ Smart Trial & Error Flow:
âœ… Confirm Clean Input Works

Start with just 127.0.0.1 â†’ works fine? Good baseline.

ğŸ” Test One Thing at a Time

Add ; â†’ blocked? âœ… ; is blacklisted.

Try &&, then |, then &, then backticks (`whoami`), then subshell $() â€” one at a time.

ğŸ“ˆ Log What Gets Through

This helps build a profile of the filter behavior:

Character-only blacklist?

Word blacklist?

WAF blocking all suspicious syntax?

ğŸ§ª Encode & Obfuscate

Try URL-encoded characters: %26, %7c, %3b

Try slight obfuscations like wh$@oami, w\hoami, etc.

ğŸ” Iterate Efficiently

You're not guessing wildly â€” you're narrowing until you find what works.

ğŸ§  Real-World Insight:
This trial-and-error process isnâ€™t just about bypassing â€” itâ€™s about profiling the defense too:

Youâ€™re learning how the app thinks.

Thatâ€™s critical CPTS skill: identifying how defenders configured security.
